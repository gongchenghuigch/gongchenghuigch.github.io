<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="前端知识体系-全栈系列, gongchenghui,github">
    <meta name="description" content="前端知识体系（图谱）
前端工程化体系
node
主流技术栈大纲
React
Vue
Angular
JavaScript
TypeScript
跨平台技术大纲
跨端技术发展的三个阶段
Hybrid
ReactNative
Flutter
w">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>前端知识体系-全栈系列 | gongchenghui</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">gongchenghui</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>主页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-rocket"></i>
            
            <span>工具</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">gongchenghui</div>
        <div class="logo-desc">
            
            北冥有鱼，其名为鲲，鲲之大，不知其几千里也； 化而为鸟，其名为鹏.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                主页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-rocket"></i>
                
                工具
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/gongchenghuigch/gongchenghuigch.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/gongchenghuigch/gongchenghuigch.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/10.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        前端知识体系-全栈系列
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/大前端/" target="_blank">
                                <span class="chip bg-color">大前端</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/大前端/" class="post-category" target="_blank">
                                大前端
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-02-02
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        21.7k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        79 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="前端知识体系（图谱）"><a href="#前端知识体系（图谱）" class="headerlink" title="前端知识体系（图谱）"></a>前端知识体系（图谱）</h1><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxgjdrrn5j317o0u0aj6.jpg" alt="前端知识体系大纲"></p>
<h2 id="前端工程化体系"><a href="#前端工程化体系" class="headerlink" title="前端工程化体系"></a>前端工程化体系</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxglag3f2j30u014k1ky.jpg" alt="前端工程化体系"></p>
<h2 id="node"><a href="#node" class="headerlink" title="node"></a>node</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxh6glc7gj30z10u0npd.jpg" alt="node"></p>
<h2 id="主流技术栈"><a href="#主流技术栈" class="headerlink" title="主流技术栈"></a>主流技术栈</h2><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmxqy9ryiyj30u014yax4.jpg" alt="主流技术栈"></p>
<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/React.png" alt></p>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/Vue.png" alt="vue"></p>
<h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/angular.png" alt></p>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/JavaScript.png" alt></p>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/TypeScript2.png" alt></p>
<h2 id="跨平台技术"><a href="#跨平台技术" class="headerlink" title="跨平台技术"></a>跨平台技术</h2><h3 id="大纲-1"><a href="#大纲-1" class="headerlink" title="大纲"></a>大纲</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%80%E6%9C%AF.png" alt></p>
<h3 id="跨端技术发展的三个阶段"><a href="#跨端技术发展的三个阶段" class="headerlink" title="跨端技术发展的三个阶段"></a>跨端技术发展的三个阶段</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95.png" alt></p>
<h3 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/Hybrid.png" alt></p>
<h3 id="ReactNative"><a href="#ReactNative" class="headerlink" title="ReactNative"></a>ReactNative</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/ReactNative.png" alt></p>
<h3 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/Flutter.png" alt></p>
<h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><h3 id="快应用"><a href="#快应用" class="headerlink" title="快应用"></a>快应用</h3><h3 id="ionic"><a href="#ionic" class="headerlink" title="ionic"></a>ionic</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/ionic.png" alt></p>
<h3 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h3><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/cordova.png" alt></p>
<h2 id="性能优化和监控"><a href="#性能优化和监控" class="headerlink" title="性能优化和监控"></a>性能优化和监控</h2><p><img src="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%92%8C%E7%9B%91%E6%8E%A7.png" alt></p>
<h1 id="前端知识体系（大纲）"><a href="#前端知识体系（大纲）" class="headerlink" title="前端知识体系（大纲）"></a>前端知识体系（大纲）</h1><h2 id="前端工程化体系-1"><a href="#前端工程化体系-1" class="headerlink" title="前端工程化体系"></a>前端工程化体系</h2><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><ul>
<li><p>规范化</p>
<ul>
<li><p>前端标准（基础）</p>
<ul>
<li>W3C</li>
<li>SPA</li>
<li>DOM</li>
<li>BOM</li>
<li>XHTML</li>
<li>XML</li>
<li>JSON</li>
<li>JSONP</li>
<li>HTTP</li>
<li>HTML5</li>
<li>CSS3</li>
</ul>
</li>
<li><p>编码规范</p>
<ul>
<li>eslint</li>
<li>tslint</li>
<li>stylelint</li>
</ul>
</li>
<li><p>命名规范</p>
<ul>
<li><p>Pascal 大小写</p>
<ul>
<li>组成标识符的每个单词的首字母大写，其余字母小写的书写约定。对于缩写的双字母单词，要求全部大写</li>
</ul>
</li>
<li><p>Camel 大小写</p>
<ul>
<li>标识符的首字母小写，每个后面连接的单词的首字母大写，其余字母小写的书写约定。对于缩写的双字母单词，要求它们出现在标识符首部时全部小写，否则全部大写</li>
</ul>
</li>
<li><p>匈牙利命名法</p>
<ul>
<li>变量名 = 属性 ＋ 类型 ＋ 对象描述</li>
</ul>
</li>
<li><p>常量的命名</p>
<ul>
<li>常量的名字应该都使用大写字母，并且指出该常量完整含义</li>
</ul>
</li>
</ul>
</li>
<li><p>目录规范</p>
</li>
<li><p>commit提交规范</p>
<ul>
<li>commitiizen</li>
<li>cz-customizable</li>
<li>commitlint</li>
</ul>
</li>
<li><p>文档规范</p>
</li>
<li><p>接口规范</p>
</li>
<li><p>流程规范</p>
<ul>
<li>gitflow</li>
</ul>
</li>
</ul>
</li>
<li><p>基础构建优化</p>
<ul>
<li><p>压缩</p>
</li>
<li><p>校验</p>
</li>
<li><p>资源合并</p>
</li>
<li><p>打包构建工具</p>
<ul>
<li>Browserify</li>
<li>webpack</li>
<li>gulp</li>
<li>rollup</li>
<li>grunt</li>
<li>…</li>
</ul>
</li>
<li><p>包管理工具</p>
<ul>
<li>Bower</li>
<li>npm</li>
<li>yarn</li>
</ul>
</li>
</ul>
</li>
<li><p>模块化</p>
<ul>
<li><p>JS模块规范</p>
<ul>
<li><p>模块规范</p>
<ul>
<li><p>AMD</p>
<ul>
<li>RequireJS</li>
</ul>
</li>
<li><p>CMD</p>
<ul>
<li>seaJS</li>
</ul>
</li>
<li><p>CommonJS</p>
<ul>
<li>node模块系统</li>
</ul>
</li>
<li><p>ES6+ Module</p>
</li>
</ul>
</li>
<li><p>模块加载机制原理</p>
</li>
</ul>
</li>
<li><p>CSS模块化</p>
<ul>
<li><p>css预处理器</p>
<ul>
<li><p>Less</p>
</li>
<li><p>Sass</p>
<ul>
<li>node-sass</li>
<li>dart-sass</li>
</ul>
</li>
<li><p>Stylus</p>
</li>
</ul>
</li>
<li><p>css Module</p>
</li>
<li><p>css in JS</p>
</li>
</ul>
</li>
<li><p>模块设计</p>
</li>
</ul>
</li>
<li><p>组件化</p>
<ul>
<li><p>组件化标准</p>
<ul>
<li>Web Component</li>
</ul>
</li>
<li><p>组件设计</p>
<ul>
<li>UI和功能拆分（独立性/自由组合）</li>
</ul>
</li>
<li><p>组件设计</p>
<ul>
<li>目录结构（就近维护）</li>
</ul>
</li>
</ul>
</li>
<li><p>资源管理</p>
<ul>
<li>按需加载</li>
<li>延迟加载</li>
<li>缓存复用</li>
<li>CDN部署</li>
<li>文件指纹</li>
<li>请求合并</li>
<li>异步同步加载</li>
</ul>
</li>
</ul>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><ul>
<li><p>脚手架</p>
<ul>
<li>脚手架工具原理</li>
<li>命令行工作流</li>
<li>项目模板设计</li>
</ul>
</li>
<li><p>搭建本地开发环境</p>
</li>
<li><p>搭建本地mock环境</p>
</li>
<li><p>自动化构建</p>
<ul>
<li>webpack配置使用</li>
<li>常用插件</li>
<li>webpack构建性能优化</li>
<li>代码转换：ES与Babel</li>
<li>CSS预编译与postcss</li>
<li>模块合并：webpack模块化构建</li>
<li>webpack增量更新构建</li>
<li>资源定位</li>
<li>自动刷新</li>
</ul>
</li>
<li><p>引入单元测试</p>
</li>
<li><p>部署发布</p>
<ul>
<li>Jenkins</li>
<li>部署流程</li>
<li>静态资源部署策略</li>
</ul>
</li>
<li><p>监控</p>
<ul>
<li><p>行为监控</p>
</li>
<li><p>异常监控</p>
<ul>
<li>采集</li>
<li>用户信息</li>
<li>行为信息</li>
<li>异常信息</li>
<li>环境信息</li>
</ul>
</li>
<li><p>性能监控</p>
<ul>
<li><p>运行时监控</p>
<ul>
<li>文件级</li>
<li>模块级</li>
<li>函数级</li>
<li>算法级</li>
</ul>
</li>
<li><p>网络请求速率</p>
</li>
<li><p>系统性能</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><ul>
<li><p>本地工作流</p>
<ul>
<li>本地环境</li>
<li>代码分离</li>
<li>测试沙箱</li>
</ul>
</li>
<li><p>云平台工作流</p>
<ul>
<li><p>角色划分</p>
<ul>
<li>本地开发环境</li>
<li>gitlab</li>
<li>云平台</li>
</ul>
</li>
<li><p>自动化构建与部署</p>
<ul>
<li>gitflow与版本管理</li>
<li>webhook与自动构建</li>
</ul>
</li>
<li><p>持续集成与持续交付</p>
<ul>
<li>自动构建与测试</li>
<li>生产环境的迭代版本、版本回流</li>
<li>Docker容器技术</li>
</ul>
</li>
<li><p>IDE云平台开发</p>
<ul>
<li>IDE工具</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul>
<li><p>Chrome</p>
<ul>
<li><p>Element 标签页</p>
<ul>
<li>用于查看和编辑当前页面中的 HTML 和 CSS 元素</li>
</ul>
</li>
<li><p>Network 标签页</p>
<ul>
<li>用于查看 HTTP 请求的详细信息，如请求头、响应头及返回内容等</li>
</ul>
</li>
<li><p>Source 标签页</p>
<ul>
<li>用于查看和调试当前页面所加载的脚本的源文件</li>
</ul>
</li>
<li><p>TimeLine 标签页</p>
<ul>
<li>用于查看脚本的执行时间、页面元素渲染时间等信息</li>
</ul>
</li>
<li><p>Profiles 标签页</p>
<ul>
<li>用于查看 CPU 执行时间与内存占用等信息</li>
</ul>
</li>
<li><p>Resource 标签页</p>
<ul>
<li>用于查看当前页面所请求的资源文件，如 HTML，CSS 样式文件等</li>
</ul>
</li>
<li><p>Audits 标签页</p>
<ul>
<li>分析页面加载的过程，进而提供减少页面加载时间、提升响应速度的方案，用于优化前端页面，加速网页加载速度等</li>
</ul>
</li>
<li><p>Console 标签页</p>
<ul>
<li>用于显示脚本中所输出的调试信息，或运行测试脚本等</li>
</ul>
</li>
</ul>
</li>
<li><p>firefox插件Firebug</p>
<ul>
<li>Chrome浏览器出现之前常用的调试工具</li>
</ul>
</li>
<li><p>IE的开发者工具</p>
</li>
<li><p>IETest</p>
<ul>
<li><p>IE浏览器版本切换工具</p>
<ul>
<li>在开发Web项目的时候，经常会碰到需要在不同的IE版本中检查完成的网页是否能正常展现，这时就需要IETest帮我们模拟网页在IE5.5、IE6、IE7、IE8、IE9以及IE10等浏览器中的兼容性，让我们看一下辛苦做好的CSS样式或网站版面是否可以在各个主要浏览器正常显示</li>
</ul>
</li>
</ul>
</li>
<li><p>Emmet</p>
<ul>
<li>HTML/CSS开发中的神器<br><a href="https://www.emmet.io/" target="_blank" rel="noopener">https://www.emmet.io/</a></li>
</ul>
</li>
<li><p>JSON 格式化和校验工具</p>
</li>
<li><p>Postman</p>
<ul>
<li>用于调试请求和响应</li>
</ul>
</li>
<li><p>移动端抓包调试</p>
<ul>
<li>fiddler</li>
<li>Charles</li>
</ul>
</li>
</ul>
<h2 id="node-1"><a href="#node-1" class="headerlink" title="node"></a>node</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li><p>web服务</p>
<ul>
<li><p>express</p>
<ul>
<li>中间件、生态完善</li>
</ul>
</li>
<li><p>koa</p>
<ul>
<li>脱胎于express，提升异步编程体验</li>
</ul>
</li>
<li><p>hapi</p>
<ul>
<li>遵循配置大于编码原则，沃尔玛前端团队出品</li>
</ul>
</li>
<li><p>sails</p>
<ul>
<li>模仿ruby on rails框架</li>
</ul>
</li>
<li><p>tsw</p>
<ul>
<li>qq空间出品，集成了很多腾讯内部组件</li>
</ul>
</li>
<li><p>Meteor</p>
<ul>
<li>快速搭建框架、10倍的减轻工作量</li>
</ul>
</li>
<li><p>Feathers</p>
<ul>
<li>创建一个面向服务的架构，是一个很好地适合创建Node.js微服务</li>
</ul>
</li>
<li><p>Keystone</p>
<ul>
<li>Keystone是得到一个管理客户端并运行的最好的解决方案之一，以便管理来自MongoDB数据库的内容。管理界面自动从模型生成，具有所有CRUD操作和精细的过滤器。</li>
</ul>
</li>
<li><p>Loopback</p>
<ul>
<li>内置许多函数，包括使用令牌和到任何类型的数据库连接器的认证</li>
</ul>
</li>
<li><p>egg</p>
<ul>
<li>为企业级框架和应用而生，是阿里开源的企业级 Node.js 框架</li>
</ul>
</li>
<li><p>Daruk</p>
<ul>
<li>Daruk 是一款基于 Koa2，使用 Typescript 开发的轻量级 web 框架</li>
</ul>
</li>
<li><p>uma</p>
<ul>
<li>58同城node框架</li>
</ul>
</li>
</ul>
</li>
<li><p>模板引擎</p>
<ul>
<li>handlebars</li>
<li>ejs</li>
<li>jade</li>
</ul>
</li>
<li><p>前端打包</p>
<ul>
<li>webpak</li>
<li>fis</li>
</ul>
</li>
<li><p>任务管理</p>
<ul>
<li>gulp</li>
</ul>
</li>
<li><p>单元测试</p>
<ul>
<li>karma</li>
<li>mocha</li>
<li>jasmine</li>
</ul>
</li>
<li><p>包管理</p>
<ul>
<li>npm</li>
<li>cnpm</li>
<li>yarn</li>
</ul>
</li>
<li><p>守护进程</p>
<ul>
<li>pm2</li>
<li>forever</li>
</ul>
</li>
</ul>
<h3 id="三大特点"><a href="#三大特点" class="headerlink" title="三大特点"></a>三大特点</h3><ul>
<li><p>单线程</p>
<p>Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的</p>
</li>
<li><p>非阻塞I/O</p>
<p>由于Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。<br>当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。<br>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。</p>
</li>
<li><p>事件驱动event-driven</p>
<p>在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。<br>Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建</p>
</li>
</ul>
<h3 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h3><ul>
<li><p>底层架构</p>
<ul>
<li><p>v8 engine</p>
<ul>
<li>虚拟机的功能，执行js代码</li>
<li>提供C++函数接口，为nodejs提供v8初始化，创建context，scope等</li>
</ul>
</li>
<li><p>libuv</p>
<ul>
<li>它是基于事件驱动的异步IO模型库，我们的js代码发出请求，最终由libuv完成，而我们所设置的回调函数则是在libuv触发</li>
</ul>
</li>
<li><p>builtin modules</p>
<ul>
<li>它是由C++代码写成各类模块，包含了crypto，zlib, file stream etc 基础功能</li>
<li>v8提供了函数接口，libuv提供异步IO模型库，以及一些nodejs函数，为builtin modules提供服务</li>
</ul>
</li>
<li><p>native modules</p>
<ul>
<li>它是由js写成，提供我们应用程序调用的库，同时这些模块又依赖builtin modules来获取相应的服务支持</li>
</ul>
</li>
</ul>
</li>
<li><p>node函数调用机制</p>
</li>
</ul>
<h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><ul>
<li><p>网络协议</p>
<ul>
<li><p>http/https</p>
<ul>
<li>推荐request.js</li>
</ul>
</li>
<li><p>tcp</p>
<ul>
<li>net模块</li>
</ul>
</li>
<li><p>udp</p>
<ul>
<li>dgram模块</li>
</ul>
</li>
</ul>
</li>
<li><p>数据序列化协议</p>
<ul>
<li><p>json</p>
<ul>
<li>文本协议，常用于http通信</li>
</ul>
</li>
<li><p>protocol buffer</p>
<ul>
<li>二进制协议，常用于socket通信</li>
<li>js原生不支持，可以使用protobuf.js来解析</li>
</ul>
</li>
</ul>
</li>
<li><p>接口协议</p>
<ul>
<li><p>restful apis</p>
<ul>
<li>语义化，几乎所有web框架都支持</li>
</ul>
</li>
<li><p>Graphql</p>
<ul>
<li>解决restful接口过于原子化的缺陷，facebook出品</li>
<li>需要在前端和后台接口之前搭建一层graphql server做数据处理</li>
</ul>
</li>
<li><p>RPC</p>
<ul>
<li>后台服务间通信</li>
</ul>
</li>
<li><p>网络序/本地序</p>
<ul>
<li>Buffer模块api原生支持两种序列的转换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li><p>数据库</p>
<ul>
<li><p>MySql</p>
</li>
<li><p>MongoDB</p>
</li>
<li><p>Oracle</p>
</li>
<li><p>MSSQL</p>
<ul>
<li>微软的SQLServer数据库服务器</li>
</ul>
</li>
<li><p>PostreSQL</p>
<ul>
<li>功能强大的开源对象关系数据库系统</li>
</ul>
</li>
<li><p>MariaSQL</p>
</li>
</ul>
</li>
<li><p>缓存</p>
<ul>
<li>redis</li>
<li>memcache</li>
<li>nosql</li>
<li>mongodb</li>
<li>orm</li>
<li>sequelize（mysql）</li>
<li>bookshelf（mysql）</li>
<li>zookeeper</li>
</ul>
</li>
<li><p>消息队列</p>
<ul>
<li><p>RabbitMQ</p>
<ul>
<li>实现了高级消息队列协议（AMQP）的开源消息代理软件</li>
</ul>
</li>
<li><p>Kafka</p>
<ul>
<li>消息队列 Kafka 版是阿里云基于 Apache Kafka 构建的高吞吐量、高可扩展性的分布式消息队列服务</li>
</ul>
</li>
<li><p>zmq</p>
<ul>
<li>是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩</li>
</ul>
</li>
<li><p>server render</p>
</li>
<li><p>websocket</p>
<ul>
<li>是一种在单个TCP连接上进行全双工通信的协议</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><p>单例模式</p>
<ul>
<li>保证一个类只有一个实例</li>
</ul>
</li>
<li><p>适配器模式</p>
<ul>
<li>适配器模式可以使原本由于接口不兼容而不能一起工作的那些类可以一起工作</li>
</ul>
</li>
<li><p>装饰模式</p>
<ul>
<li>可以通过继承的方式，为一个基类对象扩展功能</li>
</ul>
</li>
<li><p>观察者模式</p>
<ul>
<li>就是为某一对象添加一监听事件</li>
</ul>
</li>
</ul>
<h2 id="主流技术栈-1"><a href="#主流技术栈-1" class="headerlink" title="主流技术栈"></a>主流技术栈</h2><h3 id="React-1"><a href="#React-1" class="headerlink" title="React"></a>React</h3><ul>
<li><p>简介</p>
<ul>
<li>React 是一个 MVC 框架</li>
<li>React 主要是用来构建 UI</li>
<li>React 是起源于Facebook的内部项目，用于构建 Instagram 网站，在 2013.05 开源</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>声明式</p>
<ul>
<li>使用 React 编写UI界面和写HTML几乎一样</li>
</ul>
</li>
<li><p>高效</p>
<ul>
<li>React通过对DOM的模拟，最大限度地减少与DOM的交互</li>
</ul>
</li>
<li><p>灵活</p>
<ul>
<li>React可以与已知的库或框架很好地配合</li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期</p>
<ul>
<li><p>constructor</p>
<ul>
<li>构造函数</li>
</ul>
</li>
<li><p>componentWillMount</p>
<ul>
<li>在渲染前调用,在客户端也在服务端（高版本已废弃）</li>
</ul>
</li>
<li><p>componentDidMount</p>
<ul>
<li>在第一次渲染后调用，只在客户端</li>
</ul>
</li>
<li><p>componentWillReceiveProps</p>
<ul>
<li>在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用</li>
</ul>
</li>
<li><p>shouldComponentUpdate</p>
<ul>
<li>返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用</li>
</ul>
</li>
<li><p>componentWillUpdate</p>
<ul>
<li>在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用</li>
</ul>
</li>
<li><p>componentDidUpdate</p>
<ul>
<li>在组件完成更新后立即调用。在初始化时不会被调用</li>
</ul>
</li>
<li><p>componentWillUnmount</p>
<ul>
<li>在组件从 DOM 中移除的时候立刻被调用</li>
</ul>
</li>
</ul>
</li>
<li><p>React思想</p>
<ul>
<li><p>组件编写顺序</p>
<ul>
<li><p>1.组件划分原则</p>
<ul>
<li>解耦</li>
<li>复用</li>
<li>适度</li>
</ul>
</li>
<li><p>2.编写静态组件</p>
</li>
<li><p>3.分析State</p>
<ul>
<li><p>哪些是State</p>
<ul>
<li><ol>
<li>对组件进行两个灵魂质问</li>
</ol>
</li>
<li><ol start="2">
<li>对State集合进行检查和去重</li>
</ol>
</li>
</ul>
</li>
<li><p>State保存的位置</p>
<ul>
<li>单一状态</li>
<li>状态上移</li>
</ul>
</li>
</ul>
</li>
<li><ol start="4">
<li>添加交互行为</li>
</ol>
</li>
</ul>
</li>
<li><p>mock方式</p>
<ul>
<li>server</li>
<li>public</li>
</ul>
</li>
</ul>
</li>
<li><p>Redux思想</p>
<ul>
<li><p>使用redux是在解决什么问题</p>
<ul>
<li>问题原因：数据状态包括API数据，本地数据和UI状态等随着项目扩大变的管理复杂</li>
<li>解决问题的目的：防止管理状态失控</li>
<li>解决问题的手段：使用redux将视图层和状态管理层从逻辑上解耦</li>
</ul>
</li>
<li><p>State</p>
<ul>
<li>集中管理，全局唯一</li>
<li>不可变性</li>
<li>定义原则与React State定义原则相同</li>
</ul>
</li>
<li><p>Action</p>
<ul>
<li><p>普通Acion</p>
<ul>
<li>ActionCreators</li>
<li>ActionTypes</li>
</ul>
</li>
<li><p>异步Action</p>
<ul>
<li><p>异步action的创建</p>
<ul>
<li>请求开始action</li>
<li>请求成功action</li>
<li>请求失败action</li>
</ul>
</li>
<li><p>拓展reducer</p>
<ul>
<li>请求数据相关的state数据结构的变化</li>
<li>请求数据相关的reducer内容扩充</li>
</ul>
</li>
<li><p>集成redux-thunk</p>
<ul>
<li>问题原因：净化react组件的代码，想将数据请求放在action当中做</li>
<li>解决问题的目的：实现异步Action</li>
<li>解决问题的手段：使用redux-thunk实现异步Action，抽离react中的数据请求代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Reducer</p>
<ul>
<li>combineReducers</li>
</ul>
</li>
<li><p>Store</p>
</li>
<li><p>redux-devtools</p>
<ul>
<li>浏览器插件</li>
<li>项目依赖库</li>
</ul>
</li>
</ul>
</li>
<li><p>React-Redux思想</p>
<ul>
<li><p>使用react-redux是在解决什么问题</p>
<ul>
<li>问题原因：reactUI层和redux状态层的相关代码冗杂在react组件中</li>
<li>解决问题的目的：既能链接reactUI层和redux状态层，又不让两者代码糅合</li>
<li>解决问题的手段：使用react-redux将视图层和状态管理层从代码上解耦</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li>Provider组件</li>
<li>connect高阶HOC组件</li>
<li>map api</li>
</ul>
</li>
<li><p>容器性组件和展示性组件</p>
<ul>
<li>关注点</li>
<li>对redux感知</li>
<li>读数据</li>
<li>写数据</li>
<li>如何创建</li>
</ul>
</li>
<li><p>流程图总结</p>
<ul>
<li><a href="https://www.taopoppy.cn/react_redux_jiagou_react_redux.png" target="_blank" rel="noopener">https://www.taopoppy.cn/react_redux_jiagou_react_redux.png</a></li>
</ul>
</li>
</ul>
</li>
<li><p>React-Router</p>
<ul>
<li><p>服务端路由和客户端路由的区别</p>
<ul>
<li>服务端路由：访问<a href="http://a就返回a.html，访问http://b就返回b.html，是服务器根据不同的路由返回不同的页面" target="_blank" rel="noopener">http://a就返回a.html，访问http://b就返回b.html，是服务器根据不同的路由返回不同的页面</a></li>
<li>客户端路由：无论访问什么路径，返回的页面信息都是相同的，是通过js通过判断路径的不同来渲染不同的组件而已，所以叫做客户端路由</li>
</ul>
</li>
<li><p>BrowserRouter和HashRouter区别</p>
<ul>
<li>之前说react-router-dom是将react-route和web-api做绑定，这些web-api具体指的就是HTML5 history API，利用这些pushState、replaceState等方法实现在客户端实现路由的操作</li>
<li>哈希路由是使用url的hash部分作为路由信息，是通过使用页面不同的哈希和不同的组件之间做映射来完成的，哈希的出现主要为了兼容老版本浏览器，因为老版本的浏览器不支持history的API，所以通过哈希的变化来实现路由的变化。但是这样的情况在现在已经很少了，而且哈希的本身含义就是页面的定位，其逻辑也不符合路由的需求</li>
</ul>
</li>
<li><p>路由渲染组件的三种方式</p>
<ul>
<li>component</li>
<li>render</li>
<li>children</li>
</ul>
</li>
<li><p>全新思维</p>
<ul>
<li>一切皆组件</li>
<li>动态路由离散式声明法</li>
</ul>
</li>
</ul>
</li>
<li><p>架构设计基础</p>
<ul>
<li><p>React+Redux项目结构组织方式</p>
<ul>
<li><p>type（按照类型）</p>
<ul>
<li><p>定义</p>
<ul>
<li>类型指的是该文件在项目当中充当的角色类型</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>优点</p>
<ul>
<li>目录结构清晰却明确，功能文件比较紧凑</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>新添功能需要在不同的文件中做修改</li>
<li>不利于多人合作下的代码表写和提交合并</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>function（按照功能模块）</p>
<ul>
<li><p>定义</p>
<ul>
<li>功能指的是按照功能或者页面将相关的文件写在同一个文件夹</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>优点</p>
<ul>
<li>有利于新功能的开发和拓展</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>容易造成store当中存在大量重复性的数据</li>
<li>同一状态在不同的模块中会有不一致的风险</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Ducks（鸭子类型）</p>
<ul>
<li><p>定义</p>
<ul>
<li>将应用的状态作为模块的划分依据</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>目录结构清晰紧凑，添加新功能只需添加新模块文件即可</li>
<li>组件需要任何状态只需要引入对应的state模块文件即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>三种设计Redux-State的依据</p>
<ul>
<li><p>API为依据</p>
<ul>
<li><p>定义</p>
<ul>
<li>以后端API返回数据结构作为State的数据结构</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>大量数组类型的结构会造成重复数据的存在</li>
</ul>
</li>
</ul>
</li>
<li><p>UI为依据</p>
<ul>
<li><p>定义</p>
<ul>
<li>不同的UI显示都对应一份State</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>State数量过多，容易出现错误的State和重复的State</li>
</ul>
</li>
</ul>
</li>
<li><p>数据库基本原则为依据</p>
<ul>
<li>整个应用的状态按照领域分成若干子State，子State之间不能保存重复的数据</li>
<li>State以键值对的结构存储数据，以记录的key/Id作为记录的索引，记录中的其他字段都依赖于索引</li>
<li>State中不能保存可以通过已有数据计算而来的数据，即State中的字段不互相依赖</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>架构设计进阶</p>
<ul>
<li><p>selector函数</p>
<ul>
<li><p>使用selector是在解决什么问题</p>
<ul>
<li>问题原因：redux和容器性组件存在部分耦合，redux中的state结构变化会影响后者</li>
<li>解决问题的目的：实现react容器性组件和redux状态层的终极解耦</li>
<li>解决问题的手段：selectors是作为不同层级之间的接口不仅彻底解耦了层级，还使得不同层级通过接口进行安全交互和通讯得以实现</li>
</ul>
</li>
<li><p>selector带来的好处</p>
<ul>
<li>selector限制了层级的内部变化影响范围最多到接口</li>
<li>selector防止不同层级互相知道内部结构的风险</li>
<li>selector可以负责计算和过滤的工作</li>
</ul>
</li>
</ul>
</li>
<li><p>redux中间件（Middleware）</p>
<ul>
<li>middleware的写法</li>
<li>middleware的本质</li>
</ul>
</li>
<li><p>redux增强器（Enhancer）</p>
<ul>
<li><p>Enhancer的写法</p>
</li>
<li><p>Enhancer和Middleware的关系</p>
<ul>
<li>实际上middleware是store enhancer的一种，中间件虽然比较低阶，但是它约束了我们的行为，而增强器enhancer虽然更加灵活，但是破坏redux底层结构的风险更大，所以如果你对redux整体的结构和逻辑都不是太熟悉，尽量就别用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>架构设计高级</p>
<ul>
<li><p>reducer如何返回新的state对象</p>
<ul>
<li><p>Object.assign</p>
</li>
<li><p>ES6扩展语法</p>
</li>
<li><p>Immutable</p>
<ul>
<li><p>Immutable的常规使用</p>
</li>
<li><p>Immutable的优化</p>
</li>
<li><p>Immutable的选择考虑</p>
<ul>
<li>对项目的整体侵入性很强，我们需要改的地方很多，如果你的项目不是很大，且store当中的数据层级不是很多，结构不复杂，不推荐使用的，我们一定要根据需求去搭建架构，去决定是否使用某些工具</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Reselect</p>
<ul>
<li><p>使用Reselect是解决什么问题</p>
<ul>
<li>store当中的state发生了变化，每个容器型组件的mapStateToProps都要重新执行，产生的结果就是上述的这些selectors函数也要重复执行，也就导致了重复计算，使用Reselect创建的selectors函数，只要使用到的state没有发生变化，这个selectors函数就不会去重新计算，比如getVisibleTodos函数使用到了state.filter和state.todos，修改state.text并不会影响state.filter和state.todos，所以getVisibleTodos函数也就不会重复执行</li>
</ul>
</li>
<li><p>Reselect的常规使用</p>
</li>
<li><p>Reselect的选择考虑</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>React Hooks</p>
<ul>
<li><p>特性</p>
<ul>
<li>hooks 的出现使得你可以在不编写 class 的情况下使用状态管理以及其它 React 的特性</li>
</ul>
</li>
<li><p>Hooks API</p>
<ul>
<li><p>useState</p>
<ul>
<li>用来承担与类组件中的 state 一样的作用，组件内部的状态管理</li>
</ul>
</li>
<li><p>useEffect</p>
<ul>
<li>可以用来模拟生命周期，即可以完成某些副作用</li>
</ul>
</li>
<li><p>useLayoutEffect</p>
<ul>
<li>它与 useEffect 的用法完全一样，作用也基本相同，唯一的不同在于执行时机，它会在所有的 DOM 变更之后同步调用 effect，可以使用它来</li>
</ul>
</li>
<li><p>useReducer</p>
<ul>
<li>useState 的替代方案，它接收一个 (state, action) =&gt; newState 的 reducer 处理函数，并返回当前的 state 和 配套的 dispatch 方法。使用方法与 redux 非常相似</li>
</ul>
</li>
<li><p>useCallback</p>
<ul>
<li>它有的作用：性能优化，父组件更新，传递给子组件的函数指针不会每次都改变，只有当依赖项发生改变的时候才会改变指针。避免了子组件的无谓渲染</li>
<li>它的本质是对函数依赖进行分析，依赖变更时才重新执行。</li>
</ul>
</li>
<li><p>useMemo</p>
<ul>
<li>useMemo 用于缓存一些耗时的计算结果（返回值），只有当依赖项改变时才重新进行计算</li>
</ul>
</li>
<li><p>useContext</p>
<ul>
<li>专门为函数组件提供的 context hook API，可以更加方便地获取 context 的值</li>
<li>useContext(MyContext) 接收一个 context 对象，当前获取到的值由上层组件中距离最近的 &lt;MyContext.Provider&gt; 的 value 决定</li>
</ul>
</li>
<li><p>useRef</p>
<ul>
<li>useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>未完待续…</p>
</li>
</ul>
<h3 id="Angular-1"><a href="#Angular-1" class="headerlink" title="Angular"></a>Angular</h3><ul>
<li>博主未曾使用特附上一个其他大神总结的链接</li>
<li><a href="https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/angular.png" target="_blank" rel="noopener">https://img.58cdn.com.cn/escstatic/docs/imgUpload/gongchenghui/angular.png</a></li>
</ul>
<h3 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h3><ul>
<li><p>JS变量</p>
<ul>
<li><p>变量声明</p>
<ul>
<li><p>声明</p>
<ul>
<li>显示声明<br>var 变量名</li>
<li>隐式声明<br>自动添加到闭包</li>
</ul>
</li>
<li><p>陋习</p>
<ul>
<li>没有类型</li>
<li>重复声明</li>
<li>隐式声明</li>
<li>不声明直接赋值</li>
</ul>
</li>
<li><p>提倡</p>
<ul>
<li>先声明后使用</li>
<li>先赋值后运算</li>
</ul>
</li>
</ul>
</li>
<li><p>作用域</p>
<ul>
<li><p>全局变量</p>
<ul>
<li><p>包含</p>
<ul>
<li>在函数体外定义的变量</li>
<li>在函数体内定义的无var的变量</li>
</ul>
</li>
<li><p>调用</p>
<ul>
<li>任何位置</li>
</ul>
</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li><p>包含</p>
<ul>
<li>在函数体内部var声明的变量</li>
<li>函数的参数变量</li>
</ul>
</li>
<li><p>调用</p>
<ul>
<li>当前函数体内部</li>
</ul>
</li>
</ul>
</li>
<li><p>优先级</p>
<ul>
<li>局部变量高于同名全局变量</li>
<li>参数变量高于同名全局变量</li>
<li>局部变量高于同名参数变量</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li><p>忽略块级作用域</p>
</li>
<li><p>全局变量是全局对象的属性</p>
</li>
<li><p>局部变量是调用对象的属性</p>
</li>
<li><p>作用域链</p>
<ul>
<li>内层函数可访问外层函数局部变量</li>
<li>外层函数不能访问内层函数局部变量</li>
</ul>
</li>
<li><p>生命周期</p>
<ul>
<li><p>全局变量</p>
<ul>
<li>除非被显示删除，否则一直存在</li>
</ul>
</li>
<li><p>局部变量</p>
<ul>
<li>自声明起至函数执行完毕或被显示删除</li>
</ul>
</li>
<li><p>回收机制</p>
<ul>
<li>标记清除</li>
<li>引用计数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JS数据类型</p>
<ul>
<li><p>undefined</p>
<ul>
<li>使用var声明但未初始化</li>
<li>区分空对象指针与尚未定义的变量</li>
<li>对未初始化的变量及未声明的变量使用typeof都返回undefined</li>
</ul>
</li>
<li><p>null</p>
<ul>
<li>逻辑上null表示一个空对象的指针</li>
<li>使用typeof检测时会返回object</li>
</ul>
</li>
<li><p>boolean</p>
<ul>
<li><p>true为真false为假</p>
</li>
<li><p>true不一定=1 false不一定=0</p>
</li>
<li><p>使用Boolean()进行转换</p>
<ul>
<li><p>转换为true</p>
<ul>
<li>任何非空字符串</li>
<li>任何非空对象</li>
<li>任何非零数字</li>
</ul>
</li>
<li><p>转换为false</p>
<ul>
<li>空字符串</li>
<li>0和NaN</li>
<li>null及undefined</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>string</p>
<ul>
<li><p>特性</p>
<ul>
<li><p>0个或多个16位Unicode字符组成</p>
</li>
<li><p>单引号与双引号不能交叉使用</p>
</li>
<li><p>使用.length属性访问字符串长度</p>
<ul>
<li>转义序列表示一个字符串</li>
<li>无法精确返回双字节字符串长度</li>
</ul>
</li>
<li><p>字符串一旦被创建，其值将不能改变，若要改变必须销毁原有字符串</p>
</li>
</ul>
</li>
<li><p>转义序列</p>
<ul>
<li>\n 换行</li>
<li>\t 制表符</li>
<li>\b 空格</li>
<li>\r 回车</li>
<li>\f 分页符</li>
<li>\ 斜杠\</li>
<li>&#39; 单引号</li>
<li>&quot; 双引号</li>
<li>\xnn 十六进制数，n代表0~F</li>
<li>\unnnn 以十六进制表示一个Unicode字符</li>
</ul>
</li>
<li><p>类型转换</p>
<ul>
<li><p>toString()</p>
<ul>
<li><p>使用类型</p>
<ul>
<li>number</li>
<li>string</li>
<li>object</li>
<li>boolean</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>number类型的数值基数</li>
</ul>
</li>
</ul>
</li>
<li><p>String()</p>
<ul>
<li>undefined</li>
<li>null</li>
</ul>
</li>
<li><p>evel()</p>
<ul>
<li>计算字符串表达式的值并以数值的形式返回</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>number</p>
<ul>
<li><p>进制</p>
<ul>
<li>十进制</li>
<li>八进制</li>
<li>十六进制</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li><p>小数点后至少一位数字</p>
</li>
<li><p>科学计数法</p>
<ul>
<li>小数点后带有6个0的浮点数</li>
<li>以e为底*10的±N次幂</li>
</ul>
</li>
<li><p>最高精度</p>
<ul>
<li>17位小数</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>存在舍入误差</li>
<li>无法测试特定浮点数值</li>
</ul>
</li>
</ul>
</li>
<li><p>数值范围</p>
<ul>
<li><p>最小值</p>
<ul>
<li><p>Number.MIN_VALUE</p>
<ul>
<li>5e-324</li>
</ul>
</li>
</ul>
</li>
<li><p>最大值</p>
<ul>
<li><p>Number.MAX_VALUE</p>
<ul>
<li>1.7976931348623157e+308</li>
</ul>
</li>
</ul>
</li>
<li><p>超出范围</p>
<ul>
<li><p>正无穷</p>
<ul>
<li>Infinity</li>
<li>Number.POSITIVE_INFINITY</li>
</ul>
</li>
<li><p>负无穷</p>
<ul>
<li>-Infinity</li>
<li>Number.NEGATIVE_INFINITY</li>
</ul>
</li>
<li><p>缺陷</p>
<ul>
<li>无法参与下一次计算</li>
</ul>
</li>
<li><p>检测方法</p>
<ul>
<li><p>isFinite()</p>
<ul>
<li>可转换为数值 true</li>
<li>不可转换为数值 false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>NaN</p>
<ul>
<li><p>含义</p>
<ul>
<li>Not a Number</li>
<li>非数值</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li>任何涉及NaN的操作都将返回NaN</li>
<li>NaN与任何值都不相等包括自身</li>
</ul>
</li>
<li><p>检测</p>
<ul>
<li><p>isNaN()</p>
<ul>
<li>可转换为数值 false</li>
<li>不可转换为数值 true</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数值转换</p>
<ul>
<li><p>Number()</p>
<ul>
<li><p>Boolean</p>
<ul>
<li><p>true</p>
<ul>
<li>1</li>
</ul>
</li>
<li><p>false</p>
<ul>
<li>0</li>
</ul>
</li>
</ul>
</li>
<li><p>null</p>
<ul>
<li>0</li>
</ul>
</li>
<li><p>undefined</p>
<ul>
<li>NaN</li>
</ul>
</li>
<li><p>String</p>
<ul>
<li><p>只包含数字</p>
<ul>
<li>十进制数</li>
<li>前导0被忽略</li>
</ul>
</li>
<li><p>包含有浮点格式</p>
<ul>
<li>浮点数值</li>
<li>忽略前导0</li>
</ul>
</li>
<li><p>包含有效十六进制数</p>
<ul>
<li>相同大小的十进制数</li>
</ul>
</li>
<li><p>空字符串</p>
<ul>
<li>0</li>
</ul>
</li>
<li><p>其他字符串</p>
<ul>
<li>NaN</li>
</ul>
</li>
</ul>
</li>
<li><p>object</p>
<ul>
<li>基于toString转成字符串，再转换成数字</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>object</p>
<ul>
<li><p>定义</p>
<ul>
<li>一组数据或者功能的集合</li>
</ul>
</li>
<li><p>声明</p>
<ul>
<li>var obj = new Object()</li>
<li>var obj = {}</li>
</ul>
</li>
<li><p>属性与方法</p>
<ul>
<li><p>constructor</p>
<ul>
<li>保存拥有创建当前对象的函数</li>
</ul>
</li>
<li><p>hasOwnProperty</p>
<ul>
<li>检测给定属性在当前对象中是否存在</li>
</ul>
</li>
<li><p>isPrototypeOf</p>
<ul>
<li>检测传入的对象是否是另一个对象的原型</li>
</ul>
</li>
<li><p>propertyIsEnumerable</p>
<ul>
<li>检测给定的属性是否能用for-in枚举</li>
</ul>
</li>
<li><p>toLocaleString</p>
<ul>
<li>返回对象的字符串表示，该字符串与执行环境的地区对应</li>
</ul>
</li>
<li><p>toString</p>
<ul>
<li>返回对象的字符串表示</li>
</ul>
</li>
<li><p>valueOf</p>
<ul>
<li>返回对象的字符串、布尔或数值表示</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>未完待续…</p>
</li>
</ul>
<h3 id="TypeScript-1"><a href="#TypeScript-1" class="headerlink" title="TypeScript"></a>TypeScript</h3><ul>
<li><p>基础类型</p>
<ul>
<li><p>string</p>
<ul>
<li><p>同JavaScript用”或者’标识字符串</p>
<ul>
<li>let name: string = “abc”</li>
</ul>
</li>
</ul>
</li>
<li><p>number</p>
<ul>
<li><p>数组</p>
<ul>
<li><p>number[]</p>
<ul>
<li>let list: number[] = [1,2,3]</li>
</ul>
</li>
<li><p>Array&lt;元素类型&gt;</p>
<ul>
<li>let list: Array<number> = [1,2,3]</number></li>
</ul>
</li>
</ul>
</li>
<li><p>数字</p>
<ul>
<li>let decLiteral: number = 6</li>
</ul>
</li>
</ul>
</li>
<li><p>boolean</p>
<ul>
<li>let isDone: boolean = false</li>
</ul>
</li>
<li><p>Tuple</p>
<ul>
<li>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同</li>
<li>let x: [string, number];<br>x = [‘hello’, 10]; // OK</li>
</ul>
</li>
<li><p>enum</p>
<ul>
<li>枚举类型是对JavaScript标准数据类型的一个补充</li>
<li>enum Color {Red, Green, Blue}<br>let c: Color = Color.Green;</li>
</ul>
</li>
<li><p>Any</p>
<ul>
<li>未知的数据类型一般使用any</li>
</ul>
</li>
<li><p>Void</p>
<ul>
<li>void类型像是与any类型相反，它表示没有任何类型</li>
</ul>
</li>
<li><p>Null 和 Undefined</p>
<ul>
<li>undefined和null两者各自有自己的类型分别叫做undefined和null</li>
<li>它们的本身的类型用处不是很大</li>
<li>默认情况下null和undefined是所有类型的子类型</li>
</ul>
</li>
<li><p>Never</p>
<ul>
<li>never类型表示的是那些永不存在的值的类型</li>
<li>never类型是任何类型的子类型，也可以赋值给任何类型</li>
<li>没有类型是never的子类型或可以赋值给never类型（除了never本身之外）</li>
<li>即使 any也不可以赋值给never</li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li>object表示非原始类型</li>
<li>也就是除number，string，boolean，symbol，null或undefined之外的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>接口</p>
<ul>
<li><p>特殊符号</p>
<ul>
<li><p>可选</p>
<ul>
<li>?</li>
</ul>
</li>
<li><p>只读</p>
<ul>
<li>readonly</li>
</ul>
</li>
<li><p>签名</p>
<ul>
<li><p>字符串型签名</p>
</li>
<li><p>数组型签名</p>
<ul>
<li>数字型签名会将数字转换成字符串再去匹配</li>
</ul>
</li>
<li><p>如果同时使用那么数组型签名的返回值必须是字符串型签名的子类的返回值</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对象型接口</p>
<ul>
<li><p>普通模式</p>
<ul>
<li>key需要对应上</li>
</ul>
</li>
<li><p>配合签名使用的option模式</p>
</li>
</ul>
</li>
<li><p>函数型接口</p>
<ul>
<li><p>参数</p>
<ul>
<li>不需要key对应，只需要相应位置的相应类型对应</li>
</ul>
</li>
<li><p>返回值</p>
</li>
</ul>
</li>
<li><p>类类型接口</p>
<ul>
<li><p>特点</p>
<ul>
<li>接口只需要描述类的公共部分，不会去检查私有部分</li>
</ul>
</li>
<li><p>构造函数的控制方式</p>
<ul>
<li>构造函数时金泰属性，不属于公共部分</li>
<li>控制new过程</li>
</ul>
</li>
</ul>
</li>
<li><p>接口继承</p>
<ul>
<li>接口的切割和继承</li>
<li>特点：类可当做值也可以当做类型</li>
</ul>
</li>
</ul>
</li>
<li><p>类class</p>
<ul>
<li><p>定义了一件事物的抽象特点，包含它的属性和方法</p>
</li>
<li><p>ES6类的使用</p>
<ul>
<li><p>属性和方法</p>
<ul>
<li>使用class定义类</li>
<li>使用constructor定义构造函数</li>
<li>通过new生成实例会自动调用构造函数</li>
</ul>
</li>
<li><p>类的继承</p>
<ul>
<li>使用extends关键字实现继承</li>
<li>子类中使用super关键字来调用父类的构造函数和方法</li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>使用static修饰符修饰的方法称为静态类</li>
<li>不需要实例化</li>
<li>直接通过类来调用</li>
</ul>
</li>
</ul>
</li>
<li><p>TypeScript类的使用</p>
<ul>
<li><p>三种访问修饰符</p>
</li>
<li><p>public</p>
<ul>
<li>public 修饰的属性或方法是公有的，可以在任何地方被访问到</li>
<li>默认所有的属性和方法都是 public </li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>private 修饰的属性或方法是私有的</li>
<li>不能在声明它的类的外部访问</li>
<li>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 private 了</li>
<li>需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性</li>
<li>使用 private 修饰的属性或方法，在子类中也是不允许访问的</li>
</ul>
</li>
<li><p>protected</p>
<ul>
<li>protected 修饰的属性或方法是受保护的</li>
<li>它和 private 类似，区别是它在子类中也是允许被访问的</li>
</ul>
</li>
</ul>
</li>
<li><p>抽象类 </p>
<ul>
<li>抽象类是供其它类继承的基类</li>
<li>他们一般不会直接被实例化</li>
<li>抽象类可以包含成员的实现细节</li>
<li>abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法</li>
<li>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现</li>
<li>抽象方法的语法与接口方法相似。 两者都是定义方法签名不包含方法体。 然而，抽象方法必须使用abstract关键字并且可以包含访问符</li>
</ul>
</li>
<li><p>类的类型</p>
<ul>
<li>实现方式类似接口</li>
</ul>
</li>
<li><p>类实现接口</p>
<ul>
<li>实现（implements）是面向对象中的一个重要概念</li>
<li>一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现</li>
<li>这个特性大大提高了面向对象的灵活性</li>
</ul>
</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li><p>有可选参数的函数</p>
<ul>
<li>调用函数时传的参数的数量或者类型不符合函数中定义的参数要求时，TypeScript编译器会报错</li>
<li>在一些场景下我们不需要传所有的参数；TypeScript一个函数可选参数的特性；</li>
<li>在TypeScript中通过在函数参数后面追加一个?，指定参数是可选的</li>
</ul>
</li>
<li><p>有默认参数的函数</p>
<ul>
<li>当函数有可选参数时，我们必须检测参数是否被传递了</li>
<li>在声明函数签名时使用=提供一个默认值，即可指定函数参数是可选的；</li>
<li>TypeScript编译会在JavaScript输出结果中生成一个if结构</li>
</ul>
</li>
<li><p>有剩余参数的函数</p>
<ul>
<li>add = (…foo:number[]):number =&gt; {}</li>
</ul>
</li>
</ul>
</li>
<li><p>声明文件</p>
<ul>
<li><p>场景</p>
<ul>
<li>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能</li>
</ul>
</li>
<li><p>什么是声明语句</p>
<ul>
<li><p>假如我们想使用第三方库 jQuery，一种常见的方式是在 html 中通过 <script> 标签引入 jQuery，然后就可以使用全局变量 $ 或 jQuery 了</p>
<ul>
<li>$('body')</li>
</ul>
</li>
<li><p>但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西</p>
</li>
<li><p>这时，我们需要使用 declare var 来定义它的类型:</p>
<ul>
<li>declare var $: (selector: string) => any;</li>
</ul>
</li>
<li><p>declare var 并没有真的定义一个变量，只是定义了全局变量 $ 的类型，仅仅会用于编译时的检查，在编译结果中会被删除</p>
</li>
</ul>
</li>
<li><p>什么是声明文件</p>
<ul>
<li>通常我们会把声明语句放到一个单独的文件（index.d.ts）中，这就是声明文件</li>
<li>声明文件必须以.d.ts为后缀</li>
</ul>
</li>
<li><p>第三方声明文件</p>
<ul>
<li><p>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件。</p>
</li>
<li><p>@types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例：</p>
<ul>
<li>npm install @types/jquery --save-dev</li>
</ul>
</li>
</ul>
</li>
<li><p>书写声明文件</p>
<ul>
<li><p>库文件使用场景</p>
<ul>
<li><p>全局变量</p>
<ul>
<li>通过 <script> 标签引入第三方库，注入全局变量</li>
</ul>
</li>
<li><p>npm包</p>
<ul>
<li>通过 import foo from 'foo' 导入，符合 ES6 模块规范</li>
</ul>
</li>
<li><p>UMD库</p>
<ul>
<li>既可以通过 <script> 标签引入，又可以通过 import 导入</li>
</ul>
</li>
<li><p>直接扩展全局变量</p>
<ul>
<li>通过 <script> 标签引入后，改变一个全局变量的结构</li>
</ul>
</li>
<li><p>在 npm 包或 UMD 库中扩展全局变量</p>
<ul>
<li>引用 npm 包或 UMD 库后，改变一个全局变量的结构</li>
</ul>
</li>
<li><p>模块插件</p>
<ul>
<li>通过 <script> 或 import 导入后，改变另一个模块的结构</li>
</ul>
</li>
</ul>
</li>
<li><p>全局变量声明</p>
<ul>
<li><p>使用全局变量的声明文件时，如果是以 npm install @types/xxx --save-dev 安装的，则不需要任何配置。否则就需要在声明文件中声明全局变量</p>
</li>
<li><p>全局变量的几种声明方式</p>
<ul>
<li><p>declare var/const/let</p>
<ul>
<li>声明全局变量</li>
</ul>
</li>
<li><p>declare function</p>
<ul>
<li>声明全局方法</li>
</ul>
</li>
<li><p>declare class</p>
<ul>
<li>声明全局类</li>
</ul>
</li>
<li><p>declare enum</p>
<ul>
<li>声明全局枚举类型</li>
</ul>
</li>
<li><p>declare namespace</p>
<ul>
<li>声明（含有子属性的）全局对象</li>
</ul>
</li>
<li><p>interface 和 type</p>
<ul>
<li>声明全局类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>未完待续...</p>
</li>
</ul>
<h3 id="Vue-1"><a href="#Vue-1" class="headerlink" title="Vue"></a>Vue</h3><ul>
<li><p>简介</p>
<ul>
<li>Vue是一个MVVM框架</li>
<li>Vue是用于构建用户界面的渐进式框架</li>
<li>尤雨溪最开始想起名为 seed.js，但是npm已经被注册了，后来根据  ”view“起名为 vue</li>
<li>2014年由Laravel框架作者推荐后逐渐流行</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>易用</p>
<ul>
<li>已经会了 HTML、CSS、JavaScript？即刻阅读指南开始构建应用！</li>
</ul>
</li>
<li><p>灵活</p>
<ul>
<li>不断繁荣的生态系统，可以在一个库和一套完整框架之间自如伸缩。</li>
</ul>
</li>
<li><p>高效</p>
<ul>
<li>20kB min+gzip 运行大小</li>
<li>超快虚拟 DOM</li>
<li>最省心的优化</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue思想</p>
<ul>
<li>数据驱动</li>
<li>组件化</li>
</ul>
</li>
<li><p>Vue API</p>
<ul>
<li><p>应用API</p>
<ul>
<li><p>component</p>
<ul>
<li>注册或检索全局组件。注册还会使用给定的 name 参数自动设置组件的 name。</li>
</ul>
</li>
<li><p>config</p>
<ul>
<li>包含应用配置的对象。</li>
</ul>
</li>
<li><p>directive</p>
<ul>
<li>注册或检索全局指令。</li>
</ul>
</li>
<li><p>mixin</p>
<ul>
<li>在整个应用范围内应用混入。一旦注册，它们就可以在当前的应用中任何组件模板内使用它。插件作者可以使用此方法将自定义行为注入组件。不建议在应用代码中使用。</li>
</ul>
</li>
<li><p>mount</p>
<ul>
<li>将应用实例的根组件挂载在提供的 DOM 元素上</li>
</ul>
</li>
<li><p>provide</p>
<ul>
<li>设置一个可以被注入到应用范围内所有组件中的值。组件应该使用 inject 来接收 provide 的值。</li>
<li>从 provide/inject 的角度来看，可以将应用程序视为根级别的祖先，而根组件是其唯一的子级。</li>
<li>该方法不应该与 provide 组件选项或组合式 API 中的 provide 方法混淆。虽然它们也是相同的 provide/inject 机制的一部分，但是是用来配置组件 provide 的值而不是应用 provide 的值。</li>
<li>通过应用提供值在写插件时尤其有用，因为插件一般不能使用组件提供值。这是使用 globalProperties 的替代选择。</li>
</ul>
</li>
<li><p>unmount</p>
<ul>
<li>在提供的 DOM 元素上卸载应用实例的根组件。</li>
</ul>
</li>
<li><p>use</p>
<ul>
<li>安装 Vue.js 插件。如果插件是一个对象，它必须暴露一个 install 方法。如果它本身是一个函数，它将被视为安装方法。</li>
<li>该安装方法将以应用实例作为第一个参数被调用。传给 use 的其他 options 参数将作为后续参数传入该安装方法。</li>
<li>当在同一个插件上多次调用此方法时，该插件将仅安装一次</li>
</ul>
</li>
</ul>
</li>
<li><p>全局API</p>
<ul>
<li><p>createApp</p>
<ul>
<li>返回一个提供应用上下文的应用实例。应用实例挂载的整个组件树共享同一个上下文。</li>
</ul>
</li>
<li><p>h</p>
<ul>
<li>返回一个”虚拟节点“，通常缩写为 VNode：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数</li>
</ul>
</li>
<li><p>defineComponent</p>
<ul>
<li>从实现上看，defineComponent 只返回传递给它的对象。但是，就类型而言，返回的值有一个合成类型的构造函数，用于手动渲染函数、TSX 和 IDE 工具支持。</li>
</ul>
</li>
<li><p>defineAsyncComponent</p>
<ul>
<li>创建一个只有在需要时才会加载的异步组件</li>
</ul>
</li>
<li><p>resolveComponent</p>
<ul>
<li>如果在当前应用实例中可用，则允许按名称解析 component。返回一个 Component。如果没有找到，则返回 undefined。</li>
</ul>
</li>
<li><p>resolveDynamicComponent</p>
<ul>
<li>允许使用与 <component :is=""> 相同的机制来解析一个 component。返回已解析的 Component 或新创建的 VNode，其中组件名称作为节点标签。如果找不到 Component，将发出警告。</li>
</ul>
</li>
<li><p>withDirectives</p>
<ul>
<li>允许将指令应用于 VNode。返回一个包含应用指令的 VNode。</li>
</ul>
</li>
<li><p>createRenderer</p>
<ul>
<li>createRenderer 函数接受两个泛型参数： HostNode 和 HostElement，对应于宿主环境中的 Node 和 Element 类型。</li>
</ul>
</li>
<li><p>nextTick</p>
<ul>
<li>将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它</li>
</ul>
</li>
</ul>
</li>
<li><p>options</p>
<ul>
<li><p>Data</p>
<ul>
<li><p>data</p>
<ul>
<li>返回组件实例的 data 对象的函数</li>
</ul>
</li>
<li><p>props</p>
<ul>
<li>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高阶选项，如类型检测、自定义验证和设置默认值。</li>
</ul>
</li>
<li><p>computed</p>
<ul>
<li>计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例。</li>
</ul>
</li>
<li><p>methods</p>
<ul>
<li>methods 将被混入到组件实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为组件实例。</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象</li>
</ul>
</li>
<li><p>emits</p>
<ul>
<li>emits 可以是数组或对象，从组件触发自定义事件，emits 可以是简单的数组，或者对象作为替代，允许配置和事件验证</li>
</ul>
</li>
</ul>
</li>
<li><p>DOM</p>
<ul>
<li><p>template</p>
<ul>
<li>一个字符串模板作为 component 实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</li>
</ul>
</li>
<li><p>render</p>
<ul>
<li>字符串模板的另一种选择，允许你充分利用 JavaScript 的编程功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期</p>
<ul>
<li><p>beforeCreate->setup()</p>
<ul>
<li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
</ul>
</li>
<li><p>created->setup()</p>
<ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用</li>
</ul>
</li>
<li><p>beforeMount->onBeforeMount</p>
<ul>
<li>在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li><p>mounted->onMounted</p>
<ul>
<li>实例被挂载后调用，这时 Vue.createApp({}).mount() 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。</li>
<li>注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick</li>
<li>该钩子在服务器端渲染期间不被调用</li>
</ul>
</li>
<li><p>beforeUpdate->onBeforeUpdate</p>
<ul>
<li>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
<li>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行</li>
</ul>
</li>
<li><p>updated->onUpdated</p>
<ul>
<li>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
<li>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或侦听器取而代之。</li>
<li>注意，updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick</li>
<li>该钩子在服务器端渲染期间不被调用</li>
</ul>
</li>
<li><p>activated</p>
<ul>
<li>被 keep-alive 缓存的组件激活时调用。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li><p>deactivated</p>
<ul>
<li>被 keep-alive 缓存的组件停用时调用。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li><p>beforeUnmount(3.0)->onBeforeUnmount</p>
<ul>
<li>在卸载组件实例之前调用。在这个阶段，实例仍然是完全正常的。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li><p>unmounted(3.0)->onUnmounted</p>
<ul>
<li>卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
</li>
<li><p>errorCaptured->onErrorCaptured</p>
<ul>
<li>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li>
</ul>
</li>
<li><p>renderTracked(3.0)->onRenderTracked</p>
<ul>
<li>跟踪虚拟 DOM 重新渲染时调用。钩子接收 debugger event 作为参数。此事件告诉你哪个操作跟踪了组件以及该操作的目标对象和键。</li>
</ul>
</li>
<li><p>renderTriggered(3.0)->onRenderTriggered</p>
<ul>
<li>当虚拟 DOM 重新渲染为 triggered.Similarly 为renderTracked，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键。</li>
</ul>
</li>
</ul>
</li>
<li><p>选项/资源</p>
<ul>
<li><p>directives</p>
<ul>
<li>包含组件实例可用指令的哈希表。</li>
</ul>
</li>
<li><p>components</p>
<ul>
<li>包含组件实例可用组件的哈希表。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>实例property</p>
<ul>
<li><p>$data</p>
<ul>
<li>组件实例观察的数据对象。组件实例代理了对其 data 对象 property 的访问。</li>
</ul>
</li>
<li><p>$props</p>
<ul>
<li>当前组件接收到的 props 对象。组件实例代理了对其 props 对象 property 的访问。</li>
</ul>
</li>
<li><p>$el</p>
<ul>
<li>组件实例使用的根 DOM 元素。</li>
</ul>
</li>
<li><p>$options</p>
<ul>
<li>用于当前组件实例的初始化选项</li>
</ul>
</li>
<li><p>$parent</p>
<ul>
<li>父实例，如果当前实例有的话。</li>
</ul>
</li>
<li><p>$root</p>
<ul>
<li>当前组件树的根组件实例。如果当前实例没有父实例，此实例将会是其自己。</li>
</ul>
</li>
<li><p>$slots</p>
<ul>
<li>用来访问被插槽分发的内容。</li>
</ul>
</li>
<li><p>$refs</p>
<ul>
<li>一个对象，持有注册过 ref attribute 的所有 DOM 元素和组件实例。</li>
</ul>
</li>
<li><p>$attrs</p>
<ul>
<li>包含了父作用域中不作为组件 props 或自定义事件。</li>
</ul>
</li>
</ul>
</li>
<li><p>实例方法</p>
<ul>
<li><p>$watch</p>
<ul>
<li>侦听组件实例上的响应式 property 或函数计算结果的变化。</li>
</ul>
</li>
<li><p>$emit</p>
<ul>
<li>触发当前实例上的事件。附加参数都会传给监听器回调。</li>
</ul>
</li>
<li><p>$forceUpdate</p>
<ul>
<li>迫使组件实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</li>
</ul>
</li>
<li><p>$nextTick</p>
<ul>
<li>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。</li>
</ul>
</li>
</ul>
</li>
<li><p>指令</p>
<ul>
<li><p>v-text</p>
<ul>
<li>更新元素的 textContent。如果要更新部分的 textContent，需要使用 Mustache 插值。</li>
</ul>
</li>
<li><p>v-html</p>
<ul>
<li>更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</li>
</ul>
</li>
<li><p>v-show</p>
<ul>
<li>根据表达式的真假值，切换元素的 display CSS property。</li>
<li>当条件变化时该指令触发过渡效果。</li>
</ul>
</li>
<li><p>v-if</p>
<ul>
<li>根据表达式的真假值来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <template>，将提取它的内容作为条件块。</li>
<li>当条件变化时该指令触发过渡效果。</li>
<li>当和 v-for 一起使用时，v-if 的优先级比 v-for 更高</li>
</ul>
</li>
<li><p>v-else</p>
<ul>
<li>为 v-if 或者 v-else-if 添加“else 块”。</li>
</ul>
</li>
<li><p>v-else-if</p>
<ul>
<li>表示 v-if 的“else if 块”。可以链式调用。</li>
</ul>
</li>
<li><p>v-for</p>
<ul>
<li>基于源数据多次渲染元素或模板块</li>
</ul>
</li>
<li><p>v-on</p>
<ul>
<li>.stop - 调用 event.stopPropagation()。</li>
<li>.prevent - 调用 event.preventDefault()。</li>
<li>.capture - 添加事件侦听器时使用 capture 模式。</li>
<li>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li>.{keyAlias} - 仅当事件是从特定键触发时才触发回调。</li>
<li>.once - 只触发一次回调。</li>
<li>.left - 只当点击鼠标左键时触发。</li>
<li>.right - 只当点击鼠标右键时触发。</li>
<li>.middle - 只当点击鼠标中键时触发。</li>
<li>.passive - { passive: true } 模式添加侦听器</li>
<li>绑定事件监听器。事件类型由参数指定。</li>
</ul>
</li>
<li><p>v-bind</p>
<ul>
<li>动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</li>
</ul>
</li>
<li><p>v-model</p>
<ul>
<li>.lazy - 监听 change 而不是 input 事件</li>
<li>.number - 输入字符串转为有效的数字</li>
<li>.trim - 输入首尾空格过滤</li>
<li>在表单控件或者组件上创建双向绑定。</li>
</ul>
</li>
<li><p>v-slot</p>
<ul>
<li>提供具名插槽或需要接收 prop 的插槽。</li>
</ul>
</li>
<li><p>v-pre</p>
<ul>
<li>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li>
</ul>
</li>
<li><p>v-cloak</p>
<ul>
<li>这个指令保持在元素上直到关联组件实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实例准备完毕。</li>
</ul>
</li>
<li><p>v-once</p>
<ul>
<li>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li>
</ul>
</li>
<li><p>v-is</p>
<ul>
<li>在 DOM 内模板使用时，模板受原生 HTML 解析规则的约束</li>
</ul>
</li>
</ul>
</li>
<li><p>特殊指令</p>
<ul>
<li><p>key</p>
<ul>
<li>key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除/销毁 key 不存在的元素。</li>
<li>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</li>
</ul>
</li>
<li><p>ref</p>
<ul>
<li>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
</ul>
</li>
<li><p>is</p>
<ul>
<li>使用动态组件。</li>
</ul>
</li>
</ul>
</li>
<li><p>内置组件</p>
<ul>
<li><p>component</p>
<ul>
<li>渲染一个“元组件”为动态组件。依 is 的值，来决定哪个组件被渲染。is 的值是一个字符串，它既可以是 HTML 标签名称也可以是组件名称。</li>
</ul>
</li>
<li><p>transition</p>
<ul>
<li><transition> 元素作为单个元素/组件的过渡效果。<transition> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</li>
</ul>
</li>
<li><p>transition-group</p>
<ul>
<li><transition-group>提供多个元素/组件的过渡效果。默认情况下，它不呈现包装DOM元素，但可以通过tag属性定义一个。</li>
<li>注意，每个 <transition-group> 的子节点必须有独立的 key，动画才能正常工作</li>
</ul>
</li>
<li><p>keep-alive</p>
<ul>
<li><keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</li>
<li>当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</li>
<li>主要用于保留组件状态或避免重新渲染。</li>
</ul>
</li>
<li><p>slot</p>
<ul>
<li><slot> 元素作为组件模板之中的内容分发插槽。<slot> 元素自身将被替换。</li>
</ul>
</li>
<li><p>teleport</p>
<ul>
<li>允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</li>
</ul>
</li>
</ul>
</li>
<li><p>响应式API</p>
<ul>
<li><p>响应式基础API</p>
<ul>
<li><p>reactive</p>
<ul>
<li>返回对象的响应式副本</li>
<li>响应式转换是“深层”的——它影响所有嵌套 property。在基于 ES2015 Proxy 的实现中，返回的 proxy 是不等于原始对象的。建议只使用响应式 proxy，避免依赖原始对象。</li>
</ul>
</li>
<li><p>readonly</p>
<ul>
<li>获取一个对象 (响应式或纯对象) 或 ref 并返回原始 proxy 的只读 proxy。只读 proxy 是深层的：访问的任何嵌套 property 也是只读的。</li>
</ul>
</li>
<li><p>isProxy</p>
<ul>
<li>检查对象是否是由 reactive 或 readonly 创建的 proxy。</li>
</ul>
</li>
<li><p>isReactive</p>
<ul>
<li>检查对象是否是 reactive创建的响应式 proxy。</li>
</ul>
</li>
<li><p>isReadonly</p>
<ul>
<li>检查对象是否是由readonly创建的只读 proxy。</li>
</ul>
</li>
<li><p>toRaw</p>
<ul>
<li>返回 reactive 或 readonly proxy 的原始对象。这是一个转义口，可用于临时读取而不会引起 proxy 访问/跟踪开销，也可用于写入而不会触发更改</li>
</ul>
</li>
<li><p>markRaw</p>
<ul>
<li>标记一个对象，使其永远不会转换为 proxy。返回对象本身。</li>
</ul>
</li>
<li><p>shallowReactive</p>
<ul>
<li>创建一个响应式 proxy，跟踪其自身 property 的响应性，但不执行嵌套对象的深度响应式转换 (暴露原始值)。</li>
</ul>
</li>
<li><p>shallowReadonly</p>
<ul>
<li>创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换 (暴露原始值)。</li>
</ul>
</li>
</ul>
</li>
<li><p>Refs</p>
<ul>
<li><p>ref</p>
<ul>
<li>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property .value。</li>
</ul>
</li>
<li><p>unref</p>
<ul>
<li>如果参数为 ref，则返回内部值，否则返回参数本身。这是 val = isRef(val) ? val.value : val。</li>
</ul>
</li>
<li><p>toRef</p>
<ul>
<li>可以用来为源响应式对象上的 property 新创建一个 ref。然后可以将 ref 传递出去，从而保持对其源 property 的响应式连接。</li>
</ul>
</li>
<li><p>toRefs</p>
<ul>
<li>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的ref。</li>
</ul>
</li>
<li><p>isRef</p>
<ul>
<li>检查值是否是ref对象。</li>
</ul>
</li>
<li><p>customRef</p>
<ul>
<li>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 track 和 trigger 函数作为参数，并应返回一个带有 get 和 set 的对象。</li>
</ul>
</li>
<li><p>shallowRef</p>
<ul>
<li>创建一个 ref，它跟踪自己的 .value 更改，但不会使其值成为响应式的。</li>
</ul>
</li>
<li><p>triggerRef</p>
<ul>
<li>手动执行与 shallowRef 关联的任何副作用。</li>
</ul>
</li>
</ul>
</li>
<li><p>Computed和watch</p>
<ul>
<li><p>computed</p>
<ul>
<li>使用 getter 函数，并为从 getter 返回的值返回一个不变的响应式 ref 对象。</li>
</ul>
</li>
<li><p>watchEffect</p>
<ul>
<li>在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。</li>
</ul>
</li>
<li><p>watch</p>
<ul>
<li>watch API 与选项式 API this.$watch (以及相应的 watch 选项) 完全等效。watch 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生更改时调用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组合式API</p>
<ul>
<li><p>setup</p>
<ul>
<li><p>一个组件选项，在创建组件之前执行，一旦 props 被解析，并作为组合式 API 的入口点</p>
</li>
<li><p>props</p>
<ul>
<li>setup 函数中的第一个参数是 props。正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。</li>
</ul>
</li>
<li><p>context</p>
<ul>
<li>传递给 setup 函数的第二个参数是 context。context 是一个普通的 JavaScript 对象，它暴露三个组件的 property</li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期钩子</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Vuex</p>
</li>
<li><p>Vue-router</p>
</li>
<li><p>Vue-SSR</p>
</li>
<li><p>Vue-Loader</p>
</li>
<li><p>Vue-Cli</p>
<ul>
<li><p>通过 @vue/cli 实现的交互式的项目脚手架。</p>
</li>
<li><p>通过 @vue/cli + @vue/cli-service-global 实现的零配置原型开发。</p>
</li>
<li><p>一个运行时依赖 (@vue/cli-service)</p>
</li>
<li><p>Cli</p>
<ul>
<li>CLI (@vue/cli) 是一个全局安装的 npm 包，提供了终端里的 vue 命令。它可以通过 vue create 快速搭建一个新项目，或者直接通过 vue serve 构建新想法的原型。你也可以通过 vue ui 通过一套图形化界面管理你的所有项目</li>
</ul>
</li>
<li><p>Cli服务</p>
<ul>
<li><p>CLI 服务 (@vue/cli-service) 是一个开发环境依赖。它是一个 npm 包，局部安装在每个 @vue/cli 创建的项目中。</p>
</li>
<li><p>CLI 服务是构建于 webpack 和 webpack-dev-server 之上的</p>
<ul>
<li>加载其它 CLI 插件的核心服务；</li>
<li>一个针对绝大部分应用优化过的内部的 webpack 配置；</li>
<li>项目内部的 vue-cli-service 命令，提供 serve、build 和 inspect 命令</li>
</ul>
</li>
</ul>
</li>
<li><p>Cli插件</p>
<ul>
<li>CLI 插件是向你的 Vue 项目提供可选功能的 npm 包，例如 Babel/TypeScript 转译、ESLint 集成、单元测试和 end-to-end 测试等。Vue CLI 插件的名字以 @vue/cli-plugin- (内建插件) 或 vue-cli-plugin- (社区插件) 开头，非常容易使用。</li>
<li>当你在项目内部运行 vue-cli-service 命令时，它会自动解析并加载 package.json 中列出的所有 CLI 插件。</li>
<li>插件可以作为项目创建过程的一部分，或在后期加入到项目中。它们也可以被归成一组可复用的 preset</li>
</ul>
</li>
</ul>
</li>
<li><p>Vue-Devtools</p>
</li>
<li><p>vue-class-component</p>
</li>
</ul>
<h2 id="跨平台技术-1"><a href="#跨平台技术-1" class="headerlink" title="跨平台技术"></a>跨平台技术</h2><h3 id="跨端技术发展的三个阶段-1"><a href="#跨端技术发展的三个阶段-1" class="headerlink" title="跨端技术发展的三个阶段"></a>跨端技术发展的三个阶段</h3><ul>
<li><p>第一阶段是混合开发的web容器时代</p>
<ul>
<li>为了解决原生开发的高成本、低效率，出现了Hybrid混合开发</li>
<li>原生中嵌入依托于浏览器的WebView</li>
<li>Web浏览器中可以实现的需求在WebView中基本都可以实现</li>
<li>但是Web最大的问题是，它的性能和体验与原生开发存在肉眼可感知的差异</li>
<li>因此并不适用于对性能和用户体验要求较高的场景</li>
</ul>
</li>
<li><p>第二阶段是以RN和Weex为代表的泛web容器时代</p>
<ul>
<li>RN对Web标准进行了功能裁剪</li>
<li>用户体验更接近于原生了</li>
<li>由于进行了功能裁剪，所以RN对业务的支持能力还不到浏览器的5%</li>
<li>因此仅适用于中低复杂度的低交互类页面。面对稍微复杂一点儿的交互和动画需求，都需要通过调用原生代码去扩展才能实现</li>
</ul>
</li>
<li><p>第三阶段是以Flutter为代表的自绘引擎时代</p>
<ul>
<li>Flutter是构建Google物联网操作系统Fuchsia的SDK</li>
<li>它使用Dart语言开发APP</li>
<li>一套代码可以同时运行在iOS和Android平台上</li>
<li>Flutter采用自带的Native渲染引擎渲染视图，它是自己完成了组件渲染的闭环</li>
<li>而RN、Weex之类的框架，只是通过JavaScript虚拟机扩展调用系统组件，最后是由Android或者iOS系统来完成组件的渲染</li>
</ul>
</li>
</ul>
<h3 id="Hybrid-1"><a href="#Hybrid-1" class="headerlink" title="Hybrid"></a>Hybrid</h3><ul>
<li><p>为什么要引入hybrid开发</p>
<ul>
<li>Native应对急速业务需求，APP迭代加快，频繁的发版已难以应付</li>
<li>Android渠道众多，apple store审核周期长</li>
<li>纯native开发效率低，开发维护成本高，不支持热更新</li>
<li>相对于其他动态发布技术，技术研发成本较低，使用语言更广泛，社区资源更丰富</li>
</ul>
</li>
<li><p>优劣势</p>
<ul>
<li><p>原生APP</p>
<ul>
<li><p>优点</p>
<ul>
<li>打造完美的用户体验</li>
<li>性能稳定、操作速度快，上手流畅</li>
<li>访问本地资源（通讯录，相册）</li>
<li>设计出色的动效，转场</li>
<li>拥有系统级别的贴心通知或提醒</li>
<li>用户留存率高</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>分发成本高（不同平台有不同的开发语言和界面适配）</li>
<li>维护成本高</li>
<li>更新缓慢，根据不同平台，提交–审核–上线 等等不同的流程，需要经过的流程较复杂</li>
</ul>
</li>
</ul>
</li>
<li><p>Web APP</p>
<ul>
<li><p>优点</p>
<ul>
<li>发版完全自控随时更新开发成本小时间快</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>性能差弱网络无网络条件下体验差</li>
</ul>
</li>
</ul>
</li>
<li><p>Hybrid APP</p>
<ul>
<li><p>优点</p>
<ul>
<li>跨平台</li>
<li>开发周期短、成本低</li>
<li>用户体验良好</li>
<li>可以即时修复bug、动态发版</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>仿原生iOS效果复杂</li>
<li>机型兼容性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>整体架构</p>
<ul>
<li><p>viewLayer（视图层）</p>
<ul>
<li><p>H5</p>
<ul>
<li>H5页面</li>
<li>webview引擎渲染</li>
</ul>
</li>
<li><p>Native</p>
<ul>
<li>Native页面</li>
<li>系统原生引擎渲染</li>
</ul>
</li>
</ul>
</li>
<li><p>coreLayer（通信层）</p>
<ul>
<li><p>自定义webview资源拦截管理器</p>
<ul>
<li>内置资源管理</li>
<li>缓存模块</li>
<li>文件下载模块</li>
</ul>
</li>
<li><p>定义页面跳转管理器</p>
</li>
<li><p>定义混合通信交互模块</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>交互设计</p>
<ul>
<li><p>交互原理</p>
<ul>
<li><p>两种交互</p>
<ul>
<li>native主动调用前端JS</li>
<li>H5主动与native发起通信</li>
</ul>
</li>
<li><p>交互过程（OC）</p>
<ul>
<li><p>搭建JS调用OC的桥梁，注册供JS调用的方法name</p>
</li>
<li><p>JS在调用Native注册方法</p>
<ul>
<li>iOS：window.webkit.messageHandlers.自定义属性.postMessage()</li>
<li>Android：window.自定义方法</li>
</ul>
</li>
<li><p>Native接收JS调用，解析处理，返回回调</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通信方式</p>
<ul>
<li><p>假跳转的请求拦截（不建议）</p>
<ul>
<li><p>假跳转的请求拦截 就是由网页发出一条新的跳转请求，跳转的目的地是一个非法的压根就不存在的地址</p>
</li>
<li><p>比如：wbcst://testhost/action?params=xxx</p>
</li>
<li><p>模拟http协议网络请求 scheme://host/action?params</p>
</li>
<li><p>客户端会无差别拦截所有请求，真正的url地址应该照常放过，只有协议域名匹配的url地址才应该被客户端拦截</p>
</li>
<li><p>JS调用方式</p>
<ul>
<li>a标签跳转</li>
<li>location.href跳转</li>
<li>iframe跳转</li>
</ul>
</li>
<li><p>不建议使用，android系统对url参数做了字节限制，无法进行大数据的通信</p>
</li>
</ul>
</li>
<li><p>弹窗拦截（不建议）</p>
<ul>
<li><p>alert</p>
<ul>
<li>弹出个提示框，只能点确认无回调</li>
</ul>
</li>
<li><p>confirm</p>
<ul>
<li>弹出个确认框（确认，取消），可以回调</li>
</ul>
</li>
<li><p>prompt</p>
<ul>
<li>弹出个输入框，让用户输入东西，可以回调</li>
</ul>
</li>
<li><p>不建议使用，会无差别的拦截所有前端的window弹窗</p>
</li>
</ul>
</li>
<li><p>JS上下文注入（推荐）</p>
<ul>
<li><p>iOS</p>
<ul>
<li>WKWebView scriptMessageHandler注入</li>
</ul>
</li>
<li><p>android</p>
<ul>
<li>addJavascriptInterface注入</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>不通过任何拦截的办法，而是直接将一个native对象（or函数）注入到JS里面，可以由web的js代码直接调用，直接操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ReactNative-1"><a href="#ReactNative-1" class="headerlink" title="ReactNative"></a>ReactNative</h3><ul>
<li><p>简介</p>
<ul>
<li><p>特性</p>
<ul>
<li>Learn Once,Write AnyWhere</li>
<li>提供了原生控件支持</li>
<li>异步执行</li>
<li>触屏处理</li>
</ul>
</li>
<li><p>设计理念</p>
<ul>
<li>既拥有Native的用户体验</li>
<li>又保留React的开发效率</li>
</ul>
</li>
<li><p>优势</p>
<ul>
<li>它对比原生开发更为灵活，对比H5体验更为高效。</li>
<li>替代传统的WebView，打开效率更高，和原生之间的交互更方便。</li>
<li>多个版本迭代后的今天，它已经拥有了丰富第三方插件支持</li>
<li>更方便的热更新</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li>尽管是跨平台，但是不同平台Api的特性与显示并不一定一致</li>
<li>调试’相对‘麻烦。</li>
<li>Android上的兼容性问题</li>
</ul>
</li>
<li><p>风险</p>
<ul>
<li>尽管Facebook有3款App(Groups、Ads Manager、F8)使用了React Native，随着React Native大规模应用，Appstore的政策是否有变不得而知</li>
</ul>
</li>
</ul>
</li>
<li><p>环境搭建</p>
<ul>
<li><a href="https://reactnative.cn/docs/environment-setup">https://reactnative.cn/docs/environment-setup</a></li>
</ul>
</li>
<li><p>架构设计</p>
<ul>
<li><p>Native</p>
</li>
<li><p>Bridge</p>
<ul>
<li>异步（asynchronous）：不依赖于同步通信</li>
<li>可序列化（serializable）：保证一切 UI 操作都能序列化成 JSON 并转换回来</li>
<li>批处理（batched）：对 Native 调用进行排队，批量处理</li>
</ul>
</li>
<li><p>JavaScript</p>
</li>
</ul>
</li>
<li><p>组件及布局</p>
<ul>
<li><p>核心组件</p>
<ul>
<li>View</li>
<li>Text</li>
<li>ScrollView</li>
<li>Image</li>
<li>TextInput</li>
</ul>
</li>
<li><p>原生组件</p>
<ul>
<li>运行时RN为前端组件创建相应的android和iOS视图</li>
<li>RN就是对原生视图的封装</li>
</ul>
</li>
<li><p>style</p>
<ul>
<li><p>RN编写的应用的样式不是靠css来实现的</p>
</li>
<li><p>而是依赖javascript来为你的应用来添加样式</p>
</li>
<li><p>样式声明</p>
<ul>
<li><p>依赖导入</p>
<ul>
<li><code>import React, { StyleSheet } from &quot;react-native&quot;;</code></li>
</ul>
</li>
<li><p>调用React-Native的一个构造方法</p>
</li>
<li><p>传入一个对象生成style</p>
</li>
<li><p>和React的React.createCladd()语法是一样的，传入对象的key就相当于类名，每个类也是一个对象，可以配置各种样式参数</p>
</li>
<li><p>注意</p>
<ul>
<li>对象key全部是驼峰写法</li>
<li>长度不加单位</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li>`const styles = StyleSheet.create({  <pre><code>  active: {  
      borderWidth: 2,  
      borderColor: ‘#ff00ff&#39;,  
  },  </code></pre>  });`</li>
</ul>
</li>
</ul>
</li>
<li><p>样式使用</p>
<ul>
<li><p>外部引入</p>
<ul>
<li><code>&lt;View style={styles.base}&gt;&lt;/View&gt;</code></li>
</ul>
</li>
<li><p>设置多个属性类</p>
</li>
<li><p>行内样式</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>flexBox布局</p>
<ul>
<li><p>什么是FlexBox布局</p>
<ul>
<li><p>弹性盒模型（The Flexible Box Module）,又叫Flexbox，意为“弹性布局”</p>
</li>
<li><p>旨在通过弹性的方式来对齐和分布容器中内容的空间，使其能适应不同屏幕，为盒装模型提供最大的灵活性</p>
</li>
<li><p>布局思想</p>
<ul>
<li>让容器有能力让其子项目能够改变其宽度、高度（甚至是顺序）</li>
<li>以最佳方式填充可用空间</li>
</ul>
</li>
</ul>
</li>
<li><p>Flex布局基于flex-flow流</p>
<ul>
<li><p>水平的主轴（main axis）</p>
<ul>
<li>主轴的开始位置（与边框的交叉点）叫做main start</li>
<li>结束位置叫做main end</li>
</ul>
</li>
<li><p>垂直的交叉轴（cross axis）</p>
<ul>
<li>交叉轴的开始位置叫做cross start</li>
<li>结束位置叫做cross end</li>
</ul>
</li>
<li><p>项目默认沿主轴排列，单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size</p>
</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><p>4个容器属性</p>
<ul>
<li><p>flexDirection</p>
<ul>
<li>决定主轴的方向（即项目的排列方向）</li>
<li>row：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端</li>
<li>column(默认值)：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ul>
</li>
<li><p>flexWrap</p>
<ul>
<li>默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>
<li>nowrap(默认值)：不换行</li>
<li>wrap：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方。（和wrap相反）</li>
</ul>
</li>
<li><p>justifyContent</p>
<ul>
<li>定义了伸缩项目在主轴线的对齐方式</li>
<li>flex-start(默认值)：伸缩项目向一行的起始位置靠齐。</li>
<li>flex-end：伸缩项目向一行的结束位置靠齐</li>
<li>center：伸缩项目向一行的中间位置靠齐。</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：伸缩项目会平均地分布在行里，两端保留一半的空间</li>
</ul>
</li>
<li><p>alignItems</p>
<ul>
<li>定义项目在交叉轴上如何对齐，可以把其想像成侧轴（垂直于主轴）的“对齐方式”。</li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐 。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline：项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
</li>
</ul>
</li>
<li><p>2个项目属性</p>
<ul>
<li><p>flex</p>
<ul>
<li>复合属性</li>
<li>设置或检索伸缩盒对象的子元素如何分配空间</li>
<li>其中第二个和第三个参数（flex-shrink、flex-basis）是可选参数</li>
<li>默认值为“0 1 auto”</li>
</ul>
</li>
<li><p>alignSelf</p>
<ul>
<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性</li>
<li>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UI渲染</p>
<ul>
<li><p>模块注入</p>
<ul>
<li><p>RN模块注入</p>
<ul>
<li>index->App</li>
</ul>
</li>
<li><p>RN模块运行入口</p>
<ul>
<li><p>AppRegistry</p>
<ul>
<li><p>AppRegistry常用方法</p>
</li>
<li><p>registerConfig</p>
<ul>
<li>static静态方法,用来注册配置信息</li>
</ul>
</li>
<li><p>registerComponent</p>
<ul>
<li>注册组件</li>
</ul>
</li>
<li><p>registerRunnable</p>
<ul>
<li>注册线程</li>
</ul>
</li>
<li><p>runApplication</p>
<ul>
<li>进行运行应用 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>入口组件注册</p>
<ul>
<li>registerComponent</li>
</ul>
</li>
<li><p>加载jsbundle文件运行应用</p>
<ul>
<li>runApplication</li>
</ul>
</li>
</ul>
</li>
<li><p>页面启动UI渲染</p>
<ul>
<li>APP启动</li>
<li>读取模块Modules</li>
<li>初始化根视图（RCTRootView）</li>
<li>创建了一个实现 Objective-C 与 Javascript 交互的全局bridge（RCTBridge）</li>
<li>读取Javascript代码（RCTBridgeloadSource）</li>
<li>初始化Native模块化信息</li>
<li>初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象</li>
<li>执行JS调用OC组件</li>
<li>将flexbox布局转换成原生布局完成UI渲染</li>
</ul>
</li>
<li><p>UI控件渲染流程</p>
<ul>
<li><p>RCTRootView runApplication:bridge</p>
<ul>
<li>通知JS运行App</li>
</ul>
</li>
<li><p>RCTBatchedBridge _processResponse:json error:error</p>
<ul>
<li>处理执行完JS代码(runApplication)返回的相应，包含需要添加多少子控件的信息。</li>
</ul>
</li>
<li><p>RCTBatchedBridge batchDidComplete</p>
<ul>
<li>RCTUIManager调用处理完成的方法，就会开始去加载rootView的子控件。</li>
</ul>
</li>
<li><p>RCTUIManager createView:viewName:rootTag:props</p>
<ul>
<li>通过JS执行OC代码，让UI管理者创建子控件View</li>
</ul>
</li>
<li><p>[RCTUIManager _layoutAndMount]</p>
<ul>
<li>布局RCTRootView和增加子控件</li>
</ul>
</li>
<li><p>[RCTUIManager setChildren:reactTags:]</p>
<ul>
<li>给RCTRootView对应的RCTRootShadowView设置子控件</li>
</ul>
</li>
<li><p>[RCTRootShadowView insertReactSubview:view atIndex:index++]</p>
<ul>
<li>遍历子控件数组，给RCTRootShadowView插入所有子控件</li>
</ul>
</li>
<li><p>[RCTShadowView processUpdatedProperties:parentProperties:]</p>
<ul>
<li>处理保存在RCTShadowView中属性，就会去布局RCTShadowView对应UIView的所有子控件</li>
</ul>
</li>
<li><p>[RCTView didUpdateReactSubviews]</p>
<ul>
<li>给原生View添加子控件</li>
</ul>
</li>
<li><p>完成UI渲染</p>
</li>
</ul>
</li>
<li><p>通信机制</p>
<ul>
<li><p>OC生成一张模块配置表，包含所有模块和模块里的方法，根据特定的标识宏（RCT_EXPORT_MODULE()），将可以暴露的方法暴露给JS</p>
</li>
<li><p>通信流程</p>
<ul>
<li>①js调用OC模块暴露出来的方法</li>
<li>②把调用方法分解为ModuleName、MethodName、arguments，在丢给MessageQueue处理</li>
<li>③把js的callback函数缓存在MessageQueue的一个成员变量里面，同时生成一个CallbackID来代表callback；在通过保存在MessageQueue的模块配置表把ModuleName、MethodName转成ModuleID、MethodID</li>
<li>④把ModuleID、MethodID、CallbackID和其他参数传给OC（JavaScriptCore）</li>
<li>⑤OC接到消息，通过模块配置表拿到对于的模块和方法</li>
<li>⑥RCTModuleMethod对js传过来的参数进行处理</li>
<li>⑦OC模块方法执行完，执行block回调</li>
<li>⑧调用第6步中RCTModuleMethod生成的block</li>
<li>⑨block带着CallbackID和block传过来的参数去掉用js里的MessageQueue方法invokeCallbackAndReturnFlushedQueue</li>
<li>⑩MessageQueue通过CallbackID找到相应的js的callback方法</li>
<li>⑪调用callback方法，并把OC带过来的参数一起传过去完成回调</li>
</ul>
</li>
</ul>
</li>
<li><p>导航路由</p>
<ul>
<li><p>StackNavigator</p>
<ul>
<li><p>用来跳转页面和传递参数</p>
</li>
<li><p>参数</p>
<ul>
<li>RouteConfigs</li>
<li>StackNavigatorConfig</li>
</ul>
</li>
<li><p>navigation</p>
<ul>
<li><p>navigate</p>
<ul>
<li><p>跳转到其他页面</p>
</li>
<li><p>routeName</p>
<ul>
<li>导航器中配置的路由名称</li>
</ul>
</li>
<li><p>params</p>
<ul>
<li>传递参数到下一个页面</li>
</ul>
</li>
<li><p>action</p>
</li>
<li><p>示例</p>
<ul>
<li>this.props.navigation.navigate('Find', {param: 'i am the param'});</li>
</ul>
</li>
</ul>
</li>
<li><p>state</p>
<ul>
<li><p>当前页面导航器的状态</p>
</li>
<li><p>params</p>
<ul>
<li>路由页面参数</li>
</ul>
</li>
<li><p>key</p>
<ul>
<li>路由页面id</li>
</ul>
</li>
<li><p>routeName</p>
<ul>
<li>路由页面名称</li>
</ul>
</li>
</ul>
</li>
<li><p>setParams</p>
<ul>
<li>更改路由的参数</li>
<li>在组件挂载完成之后注册</li>
<li>componentDidMount() {</li>
<li>this.props.navigation.setParams({param:'i am the new param'})</li>
</ul>
</li>
<li><p>goBack</p>
<ul>
<li><p>返回</p>
</li>
<li><p>goBack()</p>
<ul>
<li>回退到上一个页面</li>
</ul>
</li>
<li><p>goBack(null)</p>
<ul>
<li>回退到任意一个页面</li>
</ul>
</li>
<li><p>goBack('pathName')</p>
<ul>
<li>回退到指定页面</li>
</ul>
</li>
</ul>
</li>
<li><p>dispatch</p>
<ul>
<li>发送一个action</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>TabNavigator</p>
<ul>
<li>类似底部导航栏，用来在同一屏切换不同页面</li>
</ul>
</li>
<li><p>DrawerNavigator</p>
<ul>
<li>侧滑菜单导航栏，用于轻松设置带抽屉的屏幕</li>
</ul>
</li>
</ul>
</li>
<li><p>拆包</p>
<ul>
<li><p>目的</p>
<ul>
<li>解决jsbundle体积过大</li>
<li>按需分步加载，提高加载效率</li>
<li>提高热更新包diff/load效率</li>
</ul>
</li>
<li><p>jsbundle组成</p>
<ul>
<li><p>头部（Polyfills）</p>
<ul>
<li>定义基本的JS环境</li>
<li>主要是define，require等全局模块的定义</li>
<li><strong>d()函数、</strong>r()函数、<strong>DEV</strong> 变量等</li>
</ul>
</li>
<li><p>中部（Module定义）</p>
<ul>
<li>模块定义，RN框架和业务的各个模块定义</li>
<li>使用__d()函数定义所有用到的模块</li>
<li>该函数为每个模块赋予了一个模块ID，模块之间的依赖关系都是通过这个ID进行关联的</li>
</ul>
</li>
<li><p>尾部（Require调用）</p>
<ul>
<li>引擎初始化和入口函数执行</li>
<li>使用__r()函数引用根模块</li>
</ul>
</li>
</ul>
</li>
<li><p>拆包方案</p>
<ul>
<li><p>diff and patch</p>
<ul>
<li>将jsbundle通过diff，生成common和每个业务的patch包</li>
<li>然后在APP运行时对common和patch合并成执行的jsbundle</li>
</ul>
</li>
<li><p>修改RN的bundle命令打包流程，使得直接生成common+business包</p>
</li>
<li><p>修改RN的unbundle命令，生成common+business包</p>
</li>
<li><p>使用metro拆包</p>
<ul>
<li><p>基础包和业务包打包</p>
<ul>
<li><p>抽离公共组件到base.js</p>
</li>
<li><p>base.js入口打包</p>
<ul>
<li>输出common.jsbundle</li>
</ul>
</li>
<li><p>index.js入口打包</p>
<ul>
<li>输出business.jsbundle</li>
</ul>
</li>
</ul>
</li>
<li><p>差异包打包</p>
<ul>
<li><p>business.jsbundle基于common.jsbundle打差异包</p>
</li>
<li><p>实现思路</p>
<ul>
<li>business.jsbundle逐行扫描</li>
<li>扫描内容如在common.jsbundle中没找到，用数组存放</li>
<li>将数组转换为数据保存到差异包patch.jsbundle</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>热更新</p>
<ul>
<li>前端业务代码提交入库</li>
<li>基于热更新平台拆分当前项目</li>
<li>资源打包上线CDN服务器</li>
<li>前端资源添加版本号管理</li>
<li>客户端拉取前端RN资源动态更新</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Flutter-1"><a href="#Flutter-1" class="headerlink" title="Flutter"></a>Flutter</h3><ul>
<li><p>Flutter发展历程</p>
<ul>
<li>2014.10 - Flutter的前身Sky在GitHub上开源 </li>
<li>2015.10 - 经过一年的开源，Sky正式改名为Flutter</li>
<li>2017.5 - Google I/O正式向外界公布了Flutter，这个时候Flutter才正式进去大家的视野</li>
<li>2018.6 - 距5月Google I/O 1个月的时间，Flutter1.0预览版</li>
<li>2018.12 - Flutter1.0发布，它的发布将大家对Flutter的学习和研究推到了一个新的起点</li>
<li>2019.2 - Flutter1.2发布主要增加对web的支持</li>
</ul>
</li>
<li><p>简介</p>
<ul>
<li>Flutter 是 Google推出并开源的移动应用开发框架</li>
<li>主打跨平台、高保真、高性能</li>
<li>开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台</li>
<li>Flutter提供了丰富的组件、接口，开发者可以很快地为 Flutter添加 native扩展</li>
<li>同时 Flutter还使用 Native引擎渲染视图，这无疑能为用户提供良好的体验</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li><p>Framework</p>
<ul>
<li>纯 Dart实现的 SDK，类似于 React在 JavaScript中的作用</li>
<li>它实现了一套基础库， 用于处理动画、绘图和手势</li>
<li>基于绘图封装了一套 UI组件库</li>
<li>根据 Material 和Cupertino两种视觉风格区分开来</li>
</ul>
</li>
<li><p>Engine</p>
<ul>
<li><p>纯 C++实现的 SDK</p>
</li>
<li><p>包括</p>
<ul>
<li>Skia引擎</li>
<li>Dart运行时</li>
<li>文字排版引擎等</li>
</ul>
</li>
<li><p>它是 Dart的一个运行时，它可以以 JIT 或者 AOT的模式运行 Dart代码</p>
</li>
<li><p>这个运行时还控制着 VSync信号的传递、GPU数据的填充等，并且还负责把客户端的事件传递到运行时中的代码</p>
</li>
</ul>
</li>
<li><p>Embedder</p>
<ul>
<li><p>Embedder是操作系统适配层</p>
</li>
<li><p>实现了</p>
<ul>
<li>渲染Surface设置</li>
<li>线程设置</li>
<li>平台插件等平台相关特性的适配</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组件渲染</p>
<ul>
<li><p>图像显示的基本原理</p>
<ul>
<li><p>显示器的CRT电子枪从上到下一行行扫描，扫描一行完成之后，显示器上就显示一帧画面，随后电子枪回到初始位置继续下一次扫描</p>
</li>
<li><p>水平扫描时，显示器会发出一个水平同步信号（HSync）</p>
</li>
<li><p>而当一帧画面绘制完成之后，电子枪恢复原位，准备下一次扫描之前，显示器会发出一个垂直同步信号（Vsync）</p>
</li>
<li><p>显示器以固定的频率刷新，这个刷新率就是Vsync信号产生的频率</p>
</li>
<li><p>图像的显示需要CPU、GPU和显示器一起配合完成</p>
<ul>
<li>CPU负责图像数据计算</li>
<li>GPU负责图像数据渲染</li>
<li>显示器则负责最终图像显示</li>
</ul>
</li>
<li><p>CPU把计算好的需要显示的内容交给GPU</p>
</li>
<li><p>由GPU完成渲染后放入帧缓冲区</p>
</li>
<li><p>随后视频控制器根据垂直同步信号（Vsync）以每秒60次的速度</p>
</li>
<li><p>从帧缓冲区读取帧数据交由显示器完成图像显示</p>
</li>
</ul>
</li>
<li><p>Flutter绘制原理</p>
<ul>
<li><p>渲染流程</p>
<ul>
<li>Dart</li>
<li>|</li>
<li>GPU</li>
<li>|</li>
<li>|</li>
<li>Compositor</li>
<li>Skia</li>
<li>GPU</li>
</ul>
</li>
<li><p>渲染流程1</p>
<ul>
<li>GPU的VSync信号同步给到UI线程</li>
<li>UI线程使用Dart来构建抽象的视图结构（这里是Framework层的工作）</li>
<li>绘制好的抽象视图数据结构在GPU线程中进行图层合成（在Flutter Engine层的工作）</li>
<li>然后提供给Skia引擎渲染为GPU数据，最后通过OpenGL或者 Vulkan提供给 GPU</li>
</ul>
</li>
<li><p>UI界面绘图流程</p>
<ul>
<li><p>user Input</p>
<ul>
<li>用户输入是驱动视图更新的信号 如：滑动屏幕</li>
</ul>
</li>
<li><p>Animation</p>
<ul>
<li>触发动画进度更新</li>
</ul>
</li>
<li><p>Build</p>
<ul>
<li>框架开始build抽象视图数据</li>
</ul>
</li>
<li><p>Layout</p>
<ul>
<li>视图布局</li>
</ul>
</li>
<li><p>Paint</p>
<ul>
<li>视图绘制</li>
</ul>
</li>
<li><p>Composite</p>
<ul>
<li>视图合成</li>
</ul>
</li>
<li><p>Restorize</p>
<ul>
<li>最后进行光栅化处理把数据生成一个个真正的像素填充数据</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Dart语言（基础）</p>
<ul>
<li><p>简介</p>
<ul>
<li>Dart 语言在2011年10月由 Google 发布</li>
<li>是一种 易于学习、 易于扩展、并且可以部署到 任何地方 的 应用 编程 语言</li>
<li>设计的初衷是用来替换javascript的，所以刚开始Dart也就是用来作<br>为浏览器脚本运行在浏览器中的，但是一直没有被广大开发者重视。</li>
<li>Google并没有放弃Dart，又Dart编写孵化了一个移动开发框架Sky，</li>
<li>之后又被命名为Flutter，进入了移动跨平台开发的领域</li>
</ul>
</li>
<li><p>应用方向</p>
<ul>
<li><p>移动端开发</p>
<ul>
<li>核心是Flutter框架，它使用</li>
<li>Dart + C++ + Skia 开发，同</li>
<li>一份代码编写运行在 iOS 和</li>
<li>Android 上的应用</li>
</ul>
</li>
<li><p>浏览器端</p>
<ul>
<li>我们用Dart来写Web后，编译器会自动</li>
<li>将Dart文件编译为JavaScript文件进行</li>
<li>运行，只不过我们写的语法规范是Dart语法</li>
</ul>
</li>
<li><p>服务器端</p>
<ul>
<li>DartVM ：就是写服务端的应用。比如写个</li>
<li>http 的服务，对应用提供 api ，都是及其简单的事情。</li>
</ul>
</li>
</ul>
</li>
<li><p>环境配置</p>
<ul>
<li><p>手动安装</p>
<ul>
<li>下载地址：<a href="http://www.gekorm.com/dart-windows/">http://www.gekorm.com/dart-windows/</a></li>
</ul>
</li>
<li><p>配置环境变量</p>
<ul>
<li>将dart-sdk的bin路径添加到path环境变量中</li>
</ul>
</li>
<li><p>在vscode中安装Code Runner插件，来调试我们的dart代码</p>
</li>
<li><p>安装stagehand</p>
<ul>
<li>pub global activate stagehand</li>
</ul>
</li>
<li><p>创建dart项目</p>
<ul>
<li>stagehand dart-demo</li>
</ul>
</li>
<li><p>获取依赖包</p>
<ul>
<li>pub get</li>
</ul>
</li>
</ul>
</li>
<li><p>常用内置类型</p>
<ul>
<li><p>String</p>
<ul>
<li>Dart 字符串是 UTF-16 编码的字符序列，可以使用单引号或者双引号来创建字符串</li>
<li>可以使用三个单引号或者双引号创建多行字符串对象</li>
<li>可以使用 r 前缀创建”原始raw”字符串</li>
<li>可以在字符串中使用表达式： ${expression},如果表达式是一个标识符，可以省略 {}，如果表达式的结果为一个对象，则 Dart 会调用对象的 toString() 函数来获取一个字符串</li>
</ul>
</li>
<li><p>Numbers</p>
<ul>
<li>int : 整数值</li>
<li>double : 64-bit双精度浮点数</li>
<li>int和double是num的子类</li>
</ul>
</li>
<li><p>Booleans</p>
<ul>
<li>bool对象未初始化的默认值是null</li>
</ul>
</li>
<li><p>Lists</p>
<ul>
<li>Dart中的数组称为List</li>
</ul>
</li>
<li><p>Maps</p>
<ul>
<li>map是一个关联键和值的对象</li>
<li>键和值都可以是任何类型的对象</li>
<li>每个键只出现一次</li>
</ul>
</li>
</ul>
</li>
<li><p>变量声明</p>
<ul>
<li><p>var</p>
<ul>
<li>类似于JavaScript中的var</li>
<li>它可以接收任何类型的变量</li>
<li>但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型</li>
<li>Dart本身是一个强类型语言</li>
<li>任何变量都是有确定类型的</li>
</ul>
</li>
<li><p>dynamic</p>
<ul>
<li>dynamic与var一样都是关键词</li>
<li>声明的变量可以赋值任意对象</li>
<li>dynamic与Object相同之处在于,他们声明的变量可以在后期改变赋值类型</li>
<li>dynamic声明的对象编译器会提供所有可能的组合</li>
</ul>
</li>
<li><p>Object</p>
<ul>
<li>Object 是Dart所有对象的根基类</li>
<li>也就是说所有类型都是Object的子类</li>
<li>包括Function和Null</li>
<li>所以任何类型的数据都可以赋值给Object声明的对象</li>
<li>Object声明的对象只能使用Object的属性与方法, 否则编译器会报错</li>
</ul>
</li>
<li><p>final</p>
<ul>
<li>一个 final 变量只能被设置一次</li>
<li>final变量在第一次使用时被初始化</li>
<li>被final或者const修饰的变量，变量类型可以省略</li>
</ul>
</li>
<li><p>const</p>
<ul>
<li>const 变量是一个编译时常量</li>
<li>不能更改</li>
</ul>
</li>
</ul>
</li>
<li><p>函数</p>
<ul>
<li>函数声明</li>
<li>对于只包含一个表达式的函数，可以使用简写语法</li>
<li>函数作为变量</li>
<li>函数作为参数传递</li>
<li>可选的位置参数</li>
<li>可选的命名参数</li>
<li>参考链接：<a href="https://book.flutterchina.club/chapter1/dart.html">https://book.flutterchina.club/chapter1/dart.html</a></li>
</ul>
</li>
<li><p>类class</p>
<ul>
<li><p>使用类成员</p>
<ul>
<li>对象的成员包括函数和数据(分别是方法和实例变量)</li>
<li>你调用一个方法时，你在一个对象上调用它:这个方法可以访问那个对象的函数和数据</li>
<li>使用点(.)引用实例变量或方法</li>
<li>使用?.而不是.为了避免最左边的操作对象为空时出现异常</li>
</ul>
</li>
<li><p>使用构造函数</p>
<ul>
<li>可以使用一个创建函数来创建对象</li>
<li>构造函数的名字可以是ClassName或者ClassName.indentifier</li>
</ul>
</li>
<li><p>构造函数</p>
<ul>
<li>通过创建一个与其类同名的函数来声明一个构造函数</li>
<li>最常见的构造函数形式——生成构造函数——创建了一个类的新实例</li>
<li>this关键词引用到当前的对象</li>
</ul>
</li>
<li><p>抽象类</p>
<ul>
<li>Dart抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口</li>
<li>抽象类通过abstract 关键字来定义</li>
<li>Dart中的抽象方法不能用abstract声明，Dart中没有方法体的方法我们称为抽象方法</li>
<li>如果子类继承抽象类必须得实现里面的抽象方法</li>
<li>如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法</li>
<li>抽象类不能被实例化，只有继承它的子类可以</li>
<li>接口：使用implements关键字，一般使用抽象类定义接口。</li>
</ul>
</li>
</ul>
</li>
<li><p>包管理</p>
<ul>
<li><p>Dart的软件包管理器是pub。</p>
</li>
<li><p>托管软件包的存储库可以在<a href="https://pub.dartlang.org/">https://pub.dartlang.org/</a> 找到</p>
</li>
<li><ul>
<li>每个Dart应用程序都有一个pubspec.yaml文件，包含了项目依赖包配置 类似package.json</li>
</ul>
</li>
<li><p>操作命令</p>
<ul>
<li>pub get：获取应用程序依赖的所有包</li>
<li>pub upgrade：将所有依赖项升级到较新版本</li>
<li>pub build：构建应用</li>
</ul>
</li>
</ul>
</li>
<li><p>库</p>
<ul>
<li><p>自定义库</p>
<ul>
<li>import 'lib/mylib1.dart' as lib1;</li>
</ul>
</li>
<li><p>系统内置库</p>
<ul>
<li>import 'dart:math';</li>
<li>import 'dart:io';</li>
<li>import 'dart:convert';</li>
</ul>
</li>
<li><p>pub包管理系统中的库</p>
<ul>
<li>import 'package:dio/dio.dart';</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Widget与Element</p>
<ul>
<li><p>什么是Widget</p>
<ul>
<li>Flutter Widget采用现代响应式框架构建，中心思想是用widget构建你的UI</li>
<li>Widget描述了他们的视图在给定其当前配置和状态时应该看起来像什么</li>
<li>当Widget的状态发生变化时， Widget会重新构建UI，Flutter会对比前后变化的不同， 以确定底层渲染树从一个状态转换到下一个状态所需的最小更改</li>
<li>Widget的功能是“描述一个UI元素的配置数据”, Widget其实并不是表示最终绘制在设备屏幕上的显示元素，而它只是描述显示元素的一个配置数据</li>
</ul>
</li>
<li><p>Element </p>
<ul>
<li>Flutter中真正代表屏幕上显示元素的类是Element，也就是说Widget只是描述Element的配置数据</li>
</ul>
</li>
<li><p>基础Widget</p>
<ul>
<li><p>StatelessWidget</p>
<ul>
<li>StatelessElement 间接继承自Element类，与StatelessWidget相对应</li>
<li>StatelessWidget用于不需要维护状态的场景</li>
<li>它通常在build方法中通过嵌套其它Widget来构建UI</li>
<li>在构建过程中会递归的构建其嵌套的Widget</li>
</ul>
</li>
<li><p>StatefulWidget</p>
<ul>
<li>和StatelessWidget一样，StatefulWidget也是继承自Widget类，并重写了createElement()方法</li>
<li>不同的是返回的Element 对象并不相同</li>
<li>StatefulWidget类中添加了一个新的接口createState()</li>
<li>createState() 用于创建和Stateful widget相关的状态，它在Stateful widget的生命周期中可能会被多次调用</li>
</ul>
</li>
<li><p>State</p>
<ul>
<li><p>一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态</p>
</li>
<li><p>State中的保存的状态信息可以</p>
<ul>
<li>在widget 构建时可以被同步读取</li>
<li>在widget生命周期中可以被改变，当State被改变时，可以手动调用其setState()方法通知Flutter framework状态发生改变，Flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的</li>
</ul>
</li>
<li><p>常用属性</p>
<ul>
<li><p>widget</p>
<ul>
<li>它表示与该State实例关联的widget实例</li>
<li>由Flutter framework动态设置</li>
</ul>
</li>
<li><p>context</p>
<ul>
<li>StatefulWidget对应的BuildContext</li>
<li>作用同StatelessWidget的BuildContext</li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期</p>
<ul>
<li><p>StatefulWidget launched</p>
</li>
<li><p>initState</p>
<ul>
<li>当Widget第一次插入到Widget树时会被调用</li>
<li>对于每一个State对象，Flutter framework只会调用一次该回调</li>
<li>通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等</li>
</ul>
</li>
<li><p>didChangeDependencies</p>
<ul>
<li>当State对象的依赖发生变化时会被调用</li>
</ul>
</li>
<li><p>build</p>
<ul>
<li><p>它主要是用于构建Widget子树的</p>
</li>
<li><p>会在如下场景被调用</p>
<ul>
<li>在调用initState()之后</li>
<li>在调用didUpdateWidget()之后</li>
<li>在调用setState()之后</li>
<li>在调用didChangeDependencies()之后</li>
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后</li>
</ul>
</li>
</ul>
</li>
<li><p>reassemble</p>
<ul>
<li>此回调是专门为了开发调试而提供的</li>
<li>在热重载(hot reload)时会被调用</li>
<li>此回调在Release模式下永远不会被调用</li>
</ul>
</li>
<li><p>didUpdateWidget</p>
<ul>
<li>在widget重新构建时</li>
<li>Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新</li>
<li>如果Widget.canUpdate返回true则会调用此回调</li>
</ul>
</li>
<li><p>deactivate</p>
<ul>
<li>当State对象从树中被移除时，会调用此回调</li>
</ul>
</li>
<li><p>dispose</p>
<ul>
<li>当State对象从树中被永久移除时调用</li>
<li>通常在此回调中释放资源</li>
</ul>
</li>
<li><p>StatefulWidget destoryed</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基础组件</p>
<ul>
<li><p>Text</p>
<ul>
<li>Text用于显示简单样式文本，它包含一些控制文本显示样式的一些属性</li>
</ul>
</li>
<li><p>Image</p>
<ul>
<li>Flutter中，我们可以通过Image组件来加载并显示图片，Image的数据源可以是asset、文件、内存以及网络</li>
</ul>
</li>
<li><p>Container</p>
<ul>
<li>Container是Flutter里很常用的容器组件， Container可以创建矩形视觉元素</li>
</ul>
</li>
</ul>
</li>
<li><p>布局类组件</p>
<ul>
<li><p>线性布局</p>
<ul>
<li>Row</li>
<li>Column</li>
</ul>
</li>
<li><p>弹性布局</p>
<ul>
<li>Flex</li>
</ul>
</li>
<li><p>流式布局</p>
<ul>
<li>Wrap</li>
<li>Flow</li>
</ul>
</li>
<li><p>层叠布局</p>
<ul>
<li>Stack</li>
<li>Positioned</li>
</ul>
</li>
<li><p>对齐与相对定位</p>
<ul>
<li>Align</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Weex"><a href="#Weex" class="headerlink" title="Weex"></a>Weex</h3><h3 id="小程序-1"><a href="#小程序-1" class="headerlink" title="小程序"></a>小程序</h3><h3 id="快应用-1"><a href="#快应用-1" class="headerlink" title="快应用"></a>快应用</h3><h3 id="ionic-1"><a href="#ionic-1" class="headerlink" title="ionic"></a>ionic</h3><ul>
<li><p>简介</p>
<ul>
<li>ionic是一个用来开发混合手机应用的，开源的，免费的代码库</li>
<li>可以优化html、css和js的性能，构建高效的应用程序</li>
<li>可以用于构建Sass和AngularJS的优化</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>具有原生APP的卓越运行性能</li>
<li>可维护性高</li>
<li>漂亮的Ui设计</li>
<li>轻量级框架</li>
<li>具有强大的命令行工具</li>
<li>与AngularJS完美结合</li>
</ul>
</li>
<li><p>框架结构</p>
<ul>
<li><p>CSS框架</p>
<ul>
<li>提供原生App质感的CSS样式模拟</li>
<li>ionic这部分的实现使用了ionicons图标样式库</li>
</ul>
</li>
<li><p>JavaScript框架</p>
<ul>
<li>提供移动Web应用开发框架</li>
<li>ionic基于AngularJS基础框架开发</li>
<li>遵循AngularJS的框架约束</li>
<li>ionic使用AngularJS UI Router实现前端路由</li>
</ul>
</li>
<li><p>命令行/CLI </p>
<ul>
<li>命令行工具集用来简化应用的开发、构造和仿真运行</li>
<li>ionic命令行工具使用了 Cordova，依赖于平台SDK（Android & iOS）实现将移动web项目打包成原生app</li>
</ul>
</li>
</ul>
</li>
<li><p>基本布局</p>
<ul>
<li><a href="https://blog.csdn.net/xyphf/article/details/53580121">https://blog.csdn.net/xyphf/article/details/53580121</a></li>
</ul>
</li>
<li><p>交互通信</p>
<ul>
<li><a href="https://user-gold-cdn.xitu.io/2018/4/23/162f220686e4dba3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">https://user-gold-cdn.xitu.io/2018/4/23/162f220686e4dba3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1</a></li>
</ul>
</li>
</ul>
<h3 id="Cordova-1"><a href="#Cordova-1" class="headerlink" title="Cordova"></a>Cordova</h3><ul>
<li><p>简介</p>
<ul>
<li>Cordova提供了一组设备相关的API</li>
<li>通过这组API，移动应用能够以JavaScript访问原生的设备功能，如摄像头、麦克风等</li>
<li>Cordova还提供了一组统一的JavaScript类库，以及为这些类库所用的设备相关的原生后台代码</li>
<li>Cordova支持如下移动操作系统：iOS, Android,ubuntu phone os, Blackberry, Windows Phone, Palm WebOS, Bada 和 Symbian</li>
</ul>
</li>
<li><p>架构</p>
<ul>
<li><p>Web APP端</p>
<ul>
<li><p>config.xml</p>
<ul>
<li><p>CLI初始化项目在主目录下生成</p>
</li>
<li><p>包含了整个app的一些基本信息</p>
<ul>
<li>appName</li>
<li>app入口文件</li>
<li>白名单</li>
<li>webview初始化的一些配置</li>
<li>plugin信息</li>
<li>图标资源信息</li>
</ul>
</li>
</ul>
</li>
<li><p>Resources</p>
</li>
<li><p>HTML、JS、CSS</p>
</li>
<li><p>cordova.js核心代码</p>
<ul>
<li><p>exec</p>
<ul>
<li>这是cordova 中js端的核心执行代码，所有的plugin的执行入口</li>
<li>successCallback -- 成功的回调</li>
<li>failCallback -- 失败的回调</li>
<li>service -- 所调用native plugin的类</li>
<li>action -- 所调用native plugin的类下的具体method</li>
<li>actionArgs -- 具体参数</li>
</ul>
</li>
<li><p>pokeNative</p>
<ul>
<li>JS通知Native调用native方法</li>
<li>通过Webview相关协议拦截前端URL</li>
<li>JS端通过iframe发送request的相关请求</li>
</ul>
</li>
<li><p>nativeCallback</p>
<ul>
<li>native处理完前端请求后触发回调的统一入口</li>
<li>以同步的方式来触发native -> js 的callBack</li>
</ul>
</li>
<li><p>callbackFromNative</p>
<ul>
<li>JS执行回调的地方</li>
<li>根据cordova.callBacks的map以及回调的callBackId 还有状态（success 或者 fail）来执行相应的回调函数</li>
<li>之后根据keepCallback来决定是否将该回调从callBacks的map中移除</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Native端</p>
<ul>
<li><p>cordova webview 引擎具体实现</p>
<ul>
<li><p>CDVViewController</p>
<ul>
<li>init --- 初始化程序</li>
<li>loadSettings --- 解析config.xml 将pluginsMap startplugin settings startPage等变量初始化到容器controller中，初始化plugin字典</li>
<li>viewDidLoad --- 先loadSettings，之后创建特殊存储空，根据CDVUIWebViewEngine初始化Webview，然后获取appURL加载index.html</li>
</ul>
</li>
<li><p>CDVUIWebViewEngine</p>
<ul>
<li>initWithFrame --- 创建webview</li>
<li>pluginInitialize --- 初始化webView中的一系列设置,创建delegate（CDVUIWebViewDelegate）</li>
<li>getConmmandInstance --- 获取command的实例</li>
</ul>
</li>
</ul>
</li>
<li><p>容器初始化以及plugin初始化</p>
<ul>
<li>Acceleromter</li>
<li>Geolocation</li>
<li>Carmera</li>
<li>Media</li>
<li>Device</li>
<li>Network</li>
<li>Contacts</li>
<li>Storage</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JS&Native通信</p>
<ul>
<li><p>通信原理</p>
<ul>
<li>保存Cordova_plugin.js的 插件文件名字和地址</li>
<li>插件的API呼出时，通过调用Cordova的exec模块将API的参数保存在CommandQueue的队列中。  CALLBACK则保存在JS侧的callbacks map里面</li>
<li>添加一个空的iframe,iframe的src则指向gap://ready</li>
<li>3的iframe的src设置以后，NATIVE侧UIWebviewDelegate#shouldStartLoadWithRequest则被呼出来</li>
<li>Webview的Delegatet判断gap://ready的情况下，则执行commandDelegate的处理</li>
<li>commandDelegate则从JS侧取出API的参数，内部实现则是通过 UIWebview＃stringByEvaluatingJavaScriptFromString的返回值 取得CommandQueue里面的参数转换成JSON数据</li>
<li>根据6的插件，执行NATIVE定义的插件实例</li>
<li>插件中，有CALLBACK的情况下，成功失败的结果通过UIWebview＃stringByEvaluatingJavaScriptFromString执行JS，JS端则根据传过来的CALLBACKID，从callbacks map取出回调函数并执行</li>
</ul>
</li>
<li><p>通信方式</p>
<ul>
<li>iframe的方法（默认）</li>
<li>xmlHttpRequest的方法（iOS5.x版本因为 -webkit-scroll的IFRAME有BUG，则推荐使用）</li>
</ul>
</li>
</ul>
</li>
<li><p>插件导入流程</p>
<ul>
<li><p>Native</p>
<ul>
<li>APP启动，MainViewController初始化之时，queue和command的DELEGATE初期化</li>
<li>config.xml文件解析，插件名设置到数组，插件文件和插件名设置到pluginMap,属性设置到setting</li>
<li>在Webview类里面，加载index.html,index.html里面加载cordova.js、开始初期化</li>
</ul>
</li>
<li><p>JS</p>
<ul>
<li>加载cordova.js时、内部的事件设置模块，NATIVE交互模块，初期化模块，插件加载</li>
<li>插件模块是cordova_plugins.js文件定义的插件文件地址，文件名保存的MAP</li>
<li>deviceready事件发布后，插件的API可以使用了</li>
<li>插件API执行后，模块MAP将插件文件加载，执行exec函数</li>
<li>在index.html里面添加一个空的iframe、指定src=gap://ready，通知到Nativie</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><ul>
<li><a href="https://www.wasm.com.cn/">https://www.wasm.com.cn/</a></li>
</ul>
<h3 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h3><h3 id="VasSonic"><a href="#VasSonic" class="headerlink" title="VasSonic"></a>VasSonic</h3><h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><h2 id="性能优化和监控-1"><a href="#性能优化和监控-1" class="headerlink" title="性能优化和监控"></a>性能优化和监控</h2><h3 id="性能优化（基础）"><a href="#性能优化（基础）" class="headerlink" title="性能优化（基础）"></a>性能优化（基础）</h3><ul>
<li><p>内容层面</p>
<ul>
<li><p>DNS解析优化</p>
<ul>
<li>DNS缓存</li>
<li>减少DNS查找</li>
<li>keep-alive</li>
<li>适当的主机域名</li>
</ul>
</li>
<li><p>避免重定向</p>
</li>
<li><p>切分到多个域名</p>
</li>
<li><p>杜绝404</p>
</li>
</ul>
</li>
<li><p>网络传输阶段</p>
<ul>
<li><p>减少传输过程中的实体大小</p>
<ul>
<li>缓存</li>
<li>cookie优化</li>
<li>文件压缩</li>
</ul>
</li>
<li><p>减少请求的次数</p>
<ul>
<li>文件适当的合并</li>
<li>雪碧图</li>
</ul>
</li>
<li><p>异步加载</p>
</li>
<li><p>预加载、延后加载、按需加载</p>
</li>
</ul>
</li>
<li><p>渲染阶段</p>
<ul>
<li>js放底部，css放顶部</li>
<li>减少重绘和回流</li>
<li>合理使用Viewport 等meta头部</li>
<li>减少dom节点</li>
<li>BigPipe</li>
</ul>
</li>
<li><p>脚本执行阶段</p>
<ul>
<li>缓存节点，尽量减少节点的查找</li>
<li>减少节点的操作（innerHTML）</li>
<li>避免无谓的循环，break、continue、return的适当使用</li>
<li>事件委托</li>
</ul>
</li>
</ul>
<h3 id="大前端时代监控"><a href="#大前端时代监控" class="headerlink" title="大前端时代监控"></a>大前端时代监控</h3><ul>
<li><p>大前端时代前端监控的新变化</p>
<ul>
<li><p>大前端时代有哪些变化</p>
<ul>
<li>首先是Gmail的横空出世，开启了SPA的时代</li>
<li>Backbone/Angular等框架带来了MVVM模式的同时，也把JS从脚本语言提升到了工程语言</li>
<li>React Native/Weex把移动端开发从Hybrid模式进化到了跨端开发模式</li>
<li>Node.js问世为前端带来了更多的可能性</li>
</ul>
</li>
<li><p>前端变化给监控带来了什么样的改变</p>
<ul>
<li>传统监控模式能否适用于新的技术？比如PV统计</li>
<li>SPA模式下首屏如何计算？</li>
<li>跨端开发给监控带来什么什么挑战？</li>
<li>前端监控的上报模式在Node.js端是否合理？</li>
</ul>
</li>
<li><p>SPA模式下的PV统计问题</p>
<ul>
<li><p>技术升级、体验升级、PV下降？</p>
</li>
<li><p>原因</p>
<ul>
<li>页内路由代替了新的页面</li>
</ul>
</li>
<li><p>解决办法</p>
<ul>
<li>hash路由：监听hash change变化上报PV</li>
<li>非哈希路由：轻量hack pushState和replaceState</li>
</ul>
</li>
</ul>
</li>
<li><p>首屏统计</p>
<ul>
<li><p>第一阶段：自定义打点时期</p>
<ul>
<li>页头和首屏dom分别通过 new Date()打点</li>
<li>计算差值作为首屏时间</li>
<li>再加上setTimeout(new Date(), 0)标记首屏可交互时间</li>
</ul>
</li>
<li><p>第二阶段：W3C标准时期</p>
<ul>
<li><p>W3C性能小组引入了 Navigation Timing API 帮我们自动,精准的实现了性能测试的打点问题</p>
</li>
<li><p>Navigation Timing API </p>
<ul>
<li>卸载上一个页面</li>
<li>重定向</li>
<li>应用缓存</li>
<li>DNS域名解析</li>
<li>TCP链接</li>
<li>请求页面</li>
<li>响应</li>
<li>页面处理</li>
<li>触发load事件</li>
</ul>
</li>
</ul>
</li>
<li><p>第三阶段：SPA盛行导致W3C标准失去原来的意义</p>
</li>
<li><p>现阶段：用户感官指标FMP</p>
<ul>
<li>first meaning paint</li>
<li>主要内容可见时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>前端监控的最佳实践</p>
<ul>
<li><p>主动监控</p>
<ul>
<li>配置告警规则</li>
<li>通过错误聚类模块，精准定位问题</li>
<li>增加性能样本分布统计</li>
<li>再手起刀落，修复bug</li>
</ul>
</li>
<li><p>慢会话追踪</p>
</li>
<li><p>搜索报错明细</p>
</li>
<li><p>出错行为还原</p>
</li>
</ul>
</li>
<li><p>58北斗监控实现</p>
</li>
</ul>
</script></p></li></ul></li></ul></li></ul>
            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <div class="center-align">
                <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                    <img alt=""
                         style="border-width:0"
                         src="https://i.creativecommons.org/l/by/4.0/88x31.png"/>
                </a>
            </div>
            <br/>
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《前端知识体系-全栈系列》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2021/02/02/前端知识体系-全栈系列/" property="cc:attributionName"
               rel="cc:attributionURL">
                浅夏晴空
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'de8dfcea77a9e87de17a',
        clientSecret: '569b91fd16e2f3972943f6907219b5ca2984aa1b',
        repo: 'gongchenghuigch.github.io',
        owner: 'gongchenghuigch',
        admin: "gongchenghuigch",
        id: '2021-02-02T17-17-38',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: 'mm',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go'
    });
</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2021/02/02/跨平台技术对比/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="跨平台技术对比">
                        
                        <span class="card-title">跨平台技术对比</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            跨平台技术发展的三个阶段
第一阶段是混合开发的web容器时代

为了解决原生开发的高成本、低效率，出现了Hybrid混合开发
原生中嵌入依托于浏览器的WebView
Web浏览器中可以实现的需求在WebView中基本都可以实现
但是Web最
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-02-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/大前端/" class="post-category" target="_blank">
                                    大前端
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/flutter/" target="_blank">
                        <span class="chip bg-color">flutter</span>
                    </a>
                    
                    <a href="/tags/ReactNative/" target="_blank">
                        <span class="chip bg-color">ReactNative</span>
                    </a>
                    
                    <a href="/tags/Hybrid/" target="_blank">
                        <span class="chip bg-color">Hybrid</span>
                    </a>
                    
                    <a href="/tags/Weex/" target="_blank">
                        <span class="chip bg-color">Weex</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/01/03/Linux服务器常用命令/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="Linux服务器常用命令">
                        
                        <span class="card-title">Linux服务器常用命令</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Linux命令大全
前言在日常开发中我们会做一些服务器部署的工作，对于开发来说，运维部署并不是我们的专项；有些命令不是经常使用，很快就会忘记；在这总结一下日常部署时常用的一些运维命令。
文件操作tailtail 命令可用于查看文件的内容，有
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-01-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Linux/" class="post-category" target="_blank">
                                    Linux
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                    <a href="/tags/shell/" target="_blank">
                        <span class="chip bg-color">shell</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            <span id="sitetime"></span> <br>
            本站由&copy;<a href="https://gongchenghuigch.github.io/" target="_blank">gongchenghui</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">214.1k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:gongch0719@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1134929850" class="tooltipped" data-tooltip="QQ联系我: 1134929850" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>
<script language = javascript >
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();
        var t1 = Date.UTC(2018, 08, 11, 00, 00, 00); //北京时间2018-2-13 00:00:00 
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond); 
        var diff = t2 - t1; var diffYears = Math.floor(diff / years); 
        var diffDays = Math.floor((diff / days) - diffYears * 365); 
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours); 
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes); 
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds); document.getElementById("sitetime").innerHTML = "本站已运行 " +diffYears+" 年 "+diffDays + " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒"; 
    } 
	siteTime(); 
</script>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>